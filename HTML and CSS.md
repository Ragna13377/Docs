# Содержание
* [1. HTML features](#1-html-features)
	* [1.1 Семантика](#11-семантика)
		* [1.1.1 Семантические блоки](#111-семантические-блоки)
		* [1.1.2 Контентные блоки](#112-контентные-блоки)
		* [1.1.3 Форматирование кода](#113-форматирование-кода)
		* [1.1.4 Базовые элементы](#114-базовые-элементы)
		* [1.1.5 Формы](#115-формы)
		* [1.1.6 Списки и таблицы](#116-списки-и-таблицы)
		* [1.1.7 Остальное](#117-остальное)
		* [1.1.8 Глобальные атрибуты](#118-глобальные-атрибуты)
	* [1.2 Метатеги](#12-метатеги)
		* [1.2.1 OpenGraph](#121-open-graph)
		* [1.2.2 Favicon](#122-favicon)
* [2 CSS features](#2-css-features)
	* [2.1 Базовые понятия](#21-базовые-понятия)
		* [2.1.1 Специфичность](#211-специфичность)
		* [2.1.2 Принцип каскада](#212-принцип-каскада)
		* [2.1.3 Наследование](#213-наследование)
		* [2.1.4 Контекст наложения](#214-контекст-наложения)
		* [2.1.5 Цвета в вебе](#215-цвета-в-вебе)
		* [2.1.6 Единицы измерения](#216-единицы-измерения)
	* [2.2 Псевдоклассы](#22-псевдоклассы)
	* [2.3 Псевдоэлементы](#23-псевдоэлементы)
	* [2.4 Анимации и Переходы](#24-анимации-и-переходы)
	* [2.5 Размеры, позиционирование и трансформации](#25-размеры-позиционирование-и-трансформации)
	* [2.6 Фон](#26-фон)
	* [2.7 Текст](#27-текст)
	* [2.8 Границы](#28-границы)
	* [2.9 Flex](#29-flex)
	* [2.10 Grid](#210-grid)
	* [2.11 Директивы](#211-директивы)
	* [2.12 Остальное](#212-остальное)

# 1. HTML features

Общая информация по всему HTML наиболее полно указано в [Доке](https://doka.guide/html/)  
В потоке существует несколько основных типов элементов:
* блочные - каждый элемент располагается на новой строке
* строчные - располагаются на одной строке с другими строчными элементами
_Строчным элементам нельзя задать размеры (ширина/высота)_
* строчно-блочные - могут располагаться на одной строке со строчными элементами
_Можно задать размеры_

## 1.1 Семантика

## 1.1.1 Семантические блоки

* `<header>` - начальное/вводное содержимое страницы/блока (в том числе `<section>`)
* `<footer>` - нижняя часть страницы/блока
* `<main>` - основное содержимое страницы. Может быть только 1 на странице  
_Внутри него не должно быть `<header>` и `<footer>`_
* `<aside>` - дополнительный контент, не относящийся к main (сайдбар, поиск по сайту)
* `<section>` - контейнер объединяющий содержимое нескольких блоков в один раздел  
_Обязательно наличие заголовка `<h.>`_
* `<article>` - самостоятельный блок контента (карточка, баннер, виджет и т.д.) 
* `<figure>` - автономный элемент, который может быть перенесен в другой блок без нарушения целостности
* `<figcaption>` - подпись для figure. Обязательно является первым или последним элементом figure
* `<nav>` - контейнер со ссылками для навигации на страницы или разделы сайта  

[Вернуться к содержанию](#содержание)

## 1.1.2 Контентные блоки

* `<address>` - контактная информация (телефон, почта, соцсети)  
_Нельзя вкладывать параграфы с текстом, заголовки, секционные (`<article>, <aside>, <nav>, <section>`)_
* `<small>` - для копирайта, информации о лицензии, правовой информации, пояснений и комментариев
* `<search>` - блок поиска/фильтра, результат поиска/фильтра
_Если резултьтаты используются совместно с поиском,_  
_то к результатам добавляется атрибут `aria-labelledby`, а к поиску `aria-label`_
* `<blockquote>` - цитируемый блок 
* `<q>` - короткая цитата
* `<cite>` - источник цитаты, **НЕ автор** (аналог атрибут `cite` в `<blockquote>` и `<q>`)
* `<time>` - блок с датой, для поискового робота добавляется атрибут `datetime`
* `<data>` - блок данных, для поискового робота добавляется атрибут `value` (`<data value="2">два</data>`)  
_Используется для связи продуктов с внутренним ID_
* `<dfn>` - вывод терминов и расшифровка сокращений. Часто используется совместно с `<abbr>`  
_Определения терминов содержатся отдельно в текстовом блоке_  

[Вернуться к содержанию](#содержание)

## 1.1.3 Форматирование кода

* `<pre>` - вывод текста без форматирования (по умолчанию в параграфе пробелы схлопываются)
* `<code>` - вывод программного кода (используется внутри `<pre>`)
* `<kbd>` - разметка пользовательского ввода с клавиатуры, голосом, другим способом 
_Атрибуты for, form, name - связывают с блоком производящим вычисления_ 
* `<samp>` - разметка вывода данных в результате выполнения программы
* `<output>` - разметка результатов вычислений, действий пользователя в **реальном** времени
* `<var>` - разметка переменных в программном коде или математических выражениях

---

* `<hr>` - смысловое разделение блоков текста
* `<br>` - перенос строки
* `<wbr>` - мягкий перенос строки
* `<sub>` - подстрочный текст (для формул)
* `<sup>` - надстрочный текст
* `<del>` - удаленная информация. В отличие от `<s>` информация об удалении **важна** для пользователя
_Информация об удалении может быть расширена через атрибуты `cite` и `datetime`_
* `<ins>` - добавленная информация. В отличие от `<u>` информация о добавлении **важна** для пользователя
_Информация о добавлении может быть расширена через атрибуты `cite` и `datetime`_
* `<mark>` - выделение текста (например при поиске на странице)
* `<strong>` - выделение текста. В отличие от `<b>` выделяемая информация **важна** для пользователя
* `<em>` - добавление смыслового акцента тексту. В отличие от `<i>` - акцентная информация важна для пользователя  

[Вернуться к содержанию](#содержание)

## 1.1.4 Базовые элементы

* `<a>` - ссылка. Строковый элемент, но внутри блочного ведет себя как блок. 
	* Атрибут `href` позволяет передать ссылку на `id` элемента (якорная ссылка)  
	* Атрибут `download` позволяет начать скачивание по ссылке. Текст в атрибуте - название для скачиваемого файла_  
	* Атрибут `target` - определяет как откроется ссылка_  
		* `_blank` в новом окне
		* `_self` на той же странице (по умолчанию)  
		* `_parent` на родительской странице (в случае `<iframe>` на странице куда вставлен `<iframe>` ),  
		* `_top` - на корневой странице (для большой вложенности iframe'ов)  
	* Атрибут `rel="noreferrer noopener"` используется совместно с `target`, для запрета передачи внешним сайтам информации о странице, откуда осуществлен переход_  
**В отличие от кнопки ссылка открывается по нажатию Enter, а не (Enter/Space)**
* `<link>` - подключение внешних ресурсов (стили, шрифты, favicon и т.д.)  
	* `href` - ссылка
	* `rel` - тип (stylesheet/icon/apple-touch-icon-precomposed и другие)
	* `sizes` - размеры для favicon
	* `media` - медиавыражение для указания условий применения
	* `crossorigin` - управление кросс-доменными запросами с заголовками CORS
	* `as` - используется совместно с `rel="preload"` или `rel="prefetch"` и другими
`preload` - зпредзагрузка критически важных ресурсов с максимальным приоритетом  
`prefetch` - предзагрузка ресурсов в фоновом режиме с наименьшим приоритетом  
`preconnect` - предварительное установление соединения с сервером для сокращения времени загрузки файлов  
`dns-prefetch` - предварительный резолвинг DNS для ускорения начального соединения
`prerender` - полная предзагрузка URL-адреса, для немедленного отображения при переходе по ссылке  
При данных типах загрузки файл не исполняется, но становится немедленно доступен при запросе
* `<map>` - обертка над несколькиими блоками `<area>`. Атрибут name совпадает с usemap у изображения
* `<area>` - разметка изображения на области (например разные области ведут на разные ссылки)
	* `shape` - форма области (circle, rect, poly)
	* стандартные атрибуты ссылки

---

* `<img>` - добавление изображения  
	* `alt` - альтернативный текст для скринридеров и при отсутствии соединения  
	* `width/heigth` - указываются для резервирования области под изображение, чтобы избежать сдвига разметки
	* `loadind` - eaget(по умолчанию)/lazy ленивая загрузка 
	* `decoding` - декодирование изображения async(отложенно)/sync(немедленно)/auto
	* `srcset` - версии картинки `srcset="logo-small.png 320w, logo-medium.png 480w, logo-large.png 800w""`  
	Также можно указывать плотность пикселей `srcset="image-1x.jpg 1x"`
	* `sizes` - доступные размеры изображения `sizes="(max-width: 320px) 280px, (max-width: 480px) 440px, 800px"`  
Порядок чтения атрибутов srcset и sizes: 
1. Браузер считывает ширину экрана
2. Определяет подходящее условие из списка sizes
3. Считывает размер блока для изображения к подходящему медиавыражению
4. Загружает изображения из списка srcset 
При этом оценка идет в большую сторону. При размере экрана в 480px выберется картинка logo-medium
* `<picture>` - адаптация изображения для разных устройств
Внутри `<picture>` обязательно находится `<img>` и опционально source.   
Если picture не поддерживается браузером или не выполнены условия из source, то `<img>` выступает в качетсве fallback
* `<audio>` - добавление аудиоплеера
	* `autoplay` - автовоспроизведение при загрузке. **Автопроигрывание в браузерах запрещено**
	* `contols` - стандартные элементы управления (альтернативно создаются на JS)
	* `loop` - зацикливание аудио
	* `muted` - громкость 0, пока пользователь ее не увеличит
	* `preload` - предзагрузка файла вместе со страницей (none/metadata/auto)
	* `src` - URL адрес
	* через вложенный элемент source можно указать несколько типов файла для совместимости форматов
* `<video>` - добавление видеоплеера
	* `autoplay, controls, loop, muted, preload` - аналогичны audio
	фоновые видео с autoplay разрешены только с атрибутом muted
	* `playsinline` - контроль воспроизведения видео в полноэкранном режиме на мобильных устройствах  
	(при добавлении запрещает полноэкранный режим)
	* `width/heigth` - размеры видео
	* `poster` - URL картинки, обложка видео, пока оно не загружено
	* через вложенный элемент source можно указать несколько типов файла для совместимости форматов
* `<iframe>` - встраиваемый элемент из стороннего источника (google maps, youtube видео)
	* `src` - URL адрес файла
	* `srcdoc` - встраивание HTML-кода целиком, без загрузки по внешней ссылке
	* `sandbox` - ограничение функционала встраиваемого документа (открытие модальных окон, управление скриптами и т.д.)
	* `loading` - ленивая загрузка  
* `<source>` - добавляет несколько источников видео/аудио/изображений для совместимости  
Вместо дублирования `<audio>/<video>` в `<source>` указывается src, srcset, sizes, media, type - MIME-тип  
`<source>` указываются в порядке приоритета типа (webm -> mp4)  
* `<object>` - встраивание PDF-документов, Flash, видео/аудио плееров  
Для аудио и видео есть собственные более подходящие теги `<audio>/<video>`

---

* `<svg>` - контейнер svg-изображения. Основные преимущества - масштабируемость, маленький вес, возможность управления стилями
	* `stroke` - цвет линий, 
	* `fill` - заливка
	* `viewBox` - размер окна отображения
	* `width/height` - размер svg-элемента
	* `preserveAspectRatio`  - сохранение пропорций при масштабировании
	* `xMinYMin, xMidYMid, xMaxYMax`  - выравнивание изображения
	* `meet` - аналог `background-size: contain`
	* `slice`  - аналог `background-size: cover`
Альтернативно svg изображения можно вставить через `<img>` или `background-image`  
Плюсы: возможность управления стилями изображения через JS . Минусы: дублирование кода  
Для решения вопроса дублирования кода и уменьшения количества запросов за ресурсами, SVG-файлы объединяются в один SVG-спрайт.  
Использование спрайта: 
1. Внутри `<svg>` каждое изображение помещается в `<symbol>`, 
2. Каждому `<symbol>` задаются атрибуты `id`, и `viewBox` - область на спрайте соответствующая изображеню  
3. Вызов изображения происходит с помощью `<use href="pathToSprite#ID">`

```javascript
<svg xmlns="http://www.w3.org/2000/svg">
	...
  <symbol id="social-facebook" viewBox="0 0 6 12">
		<path d="M1.09903 2.72854C1.09903 ..."/>
		  </symbol>

  <symbol id="social-twitter" viewBox="0 0 16 11">
    <path d="M13.3758 4.62011C14.2231 ..."/>
  </symbol>
  ...
</svg>

<svg class="social-icon" viewBox="0 0 24 24" width="24" height="24">
  <use href="sprite.svg#social-vk"></use>
</svg>
```
Для создания фонового спрайта необходимо использовать именованные фрагменты в SVG (расположить изображения друг за другом/по сетке).  
Изменение фона происходит с помощью сдвига области просмотра в `<view>`  
```javascript
<svg>
	<view id="icon-first-view" viewBox="0 0 24 24"/>
	<path d="M4 12V20C4 20.5304 ..."/>
	
	<view id="icon-second-view" viewBox="0 24 24 24"/>
  <path d="M4 12V20C4 20.5304 ..."/>
</svg>

.image {
	background-image: url('fragments.svg#svgView(viewBox(0, 0, 24, 48))');
}
```
При расположении один под другим используется подход (изображения вне таргета выключаются в стиля): 
```javascript
<svg xmlns="http://www.w3.org/2000/svg">
	<defs>
		<style>
      g { display: none; }
      g:target { display: inline; }
    </style>
	</defs>
	<g id="cat">
    <path d="M9 13.125C9 13.3475 ..." fill="black"/>
  </g>
</svg>
```  

[Вернуться к содержанию](#содержание)

## 1.1.5 Формы

* `<form>` - элемент формы. Данные с формы отправляются синхронно, перезагружая страницу. Для измеения поведения используется JS
	* `action` - ссылка на скрипт-обработчик
	* `method` - способ отправки данный (get(ограничен по длине запроса 3000 символами для url)/put/patch/post/delete)
	* `name` - идентификатор формы
	* `autocomplete` - автозаполнение формы/другого элемента с вводом данных (по умолчанию включено)  
	В атрибуте можно указать тип данных для автозаполнения [Типы данных](https://doka.guide/html/autocomplete/)  
	Атрибут может перезаписываться дочерними элементами
	* `novalidate` - отключает браузерную валидацию полей формы (браузерные ошибки валидации)
	* `enctype` - вид кодирования формы
		* `multipart/form-data` - отправка файлов
		* `text/plain` - пробелы заменяются на `+`
		* `application/x-www-form-urlencoded` - по умолчанию, пробелы заменяются на `+`, кириллица кодируется в 16-бит
		* `accept-charset` - кодировка принимаемых данных сервером (значение UNKNOWN принимает кодировку страницы)
Для связи элементов с формой они помещаются внутрь формы или используют атрибут `for` для связи с `id` формы
* `<input>` - поле ввода  
	* `type` - основной атрибут  
	`text, email, search, tel, url, password, number` - определяющий тип вводимой информации,  
	в зависимости от которого формируется пользовательская клавиатура мобильных девайсов  
  Альтернативно можно задавать тип ввода в атрибуте `inputmode`
	`sumbit, button, image, reset` - имитация кнопки  
	`radio, range, checkbox, color, date, file` - различные элементы форм
	* `value` - изменяется в зависимости от типа (sumbit, button, reset надпись над кнопкой,  
	image - коорданаты относительно изображения, password/text - значение поля, checkbox - уникальное значение элемента) 
	* `list` - связывает с datalist **Не для hidden, password, checkbox, radio, file, кнопок**
	* `step, min, max` - для number, range, date
	* `size` - ширина поля ввода
	* `pattern` - кастомная валидация regexp
	* `multiple` - возможность выбрать больше одного значения (совместим с email, file)
	* `accept` - тип прикрепляемых файлов (пользователь в праве изменить тип передаваемого файла, поэтому требуется проверка типа перед отправкой)
	* `capture` - добавляет выбор камеры телефона (совместим с file). Работает **только** в мобильных браузерах  
	user - фронтальная, environment - задняя
* `<textarea>` - многострочное поле ввода
	* `cols, rows ` - ширина/высота поля ввода в строках
	* `wrap` - добавление символов переноса строк при отправке текста с формы (hard(добавляются)/soft(не добавляются))
Важное стилистическое свойство `resize` запрещает изменять размер элемента, разрешенный по умолчанию
* `<button>` - кнопка
	* `formaction, formenctype, formmethod, formnovalidate` - аналоги атрибутов на форме
	* `formtarget` - аналог `target` ссылки `<a>`
	* `type` - `sumbit, reset, button` типы кнопки
	* `value` - исходное значение кнопки, отправляемое вместе с данными пользователя  
В отличие от `<input>` кнопки позволяет добавить внутрь дочерние элементы
* `<select>` - выпадающий список.  
	* `size` - количество видимых элементов списка
	* `multiple` - возможность загрузить больше одного зфайла (совместим с email, file)
Внутри элемента могут быть только `<option>` - поля выбора с уникальными значениями `value` и `<optgroup>` - группы полей 
`selected` - изначально выбранный элемент
* `<option>` - элемент выпадающего списка (имеет больший приоритет, чем текст между тегами)
	* `label` - текст элемента
	* `value` - отправляемое значение при выборе элемента (если не указано отправляется текстовое содержимое)
* `<optgroup>` - группа `<option>`. `Label` - обязательный атрибут текстового описания
* `<datalist>` - выпадающий список вариантов автозаполнения (не видим пока нет взаимодействия со связанным `<input>`)  
Отличие от `<select>` можно выбрать значение *НЕ* из списка предложенных
* `<label>` - подпись элемента формы  
Для связи с формой/элементом, форме/элементу задается `id`, а в `<label>` указывается атрибут `for`  
Альтернативно форма/элемент оборачивается в `<label>`  
Элемент можно связать с `<button>, <input>, <meter>, <output>, <progress>, <select> и <textarea>`  
Одному элементу соотсветвует один `<label>`
* `<fieldset>` - смысловая группировка элементов формы (например нескольких полей ввода)  
* `<legend>` - заголовок `<fieldset>`. **Должен быть** первым дочерним элементом

### Общие атрибуты интерактивных элементов  

+ `required` - делает поле обязательным
+ `disabled` - отключает элемент
+ `form` - связывает с формой
+ `autocomplete, autofocus`
+ `name` - уникальное имя элемента
+ `readonly` - делает элемент доступным только для чтения (для текстовых полей)
+ `placeholder` - текст подсказка внутри текстового поля
+ `minlength, maxlength` - минимальное/максимальное число символов (для текстовых полей)  
	
[Вернуться к содержанию](#содержание)

## 1.1.6 Списки и таблицы

* `<ol>` - упорядоченный список однотипных элементов связанных по смыслу
* `<ul>` - неупорядоченный список однотипных элементов
* `<li>` - элемент списка. Имеет собственный `display: list-item`, что генерирует `:marker`
* `<dl>, <dt>, <dd>` - список терминов, где `<dt>` - термин, `<dd>` - описание.  
Соотношение между терминами и описаниями - любое (не обязательно 1:1)

---

* `<table>` - таблица
	* `<tr>` - строка таблицы
	* `<td>` - ячейка таблицы
	* `<th>` - ячейка заголовка таблицы
	* `<thead>, <tbody>, `<tfoot>` - логическая группировка ячеек
	* `<caption>` - подпись к таблице. Первый элемент после открывающего `<table>`
Атрибуты `rowspan` и `colspan` объединяеют ячейки по высоте/ширине  

[Вернуться к содержанию](#содержание)

## 1.1.7 Остальное 

* `<meter>` - прогресс бар с изменяющимися цветовыми значениями в зависимости от value и границ min/max/low/high 
Используется вместе с `<label>`  
Атрибуты: `value, min, max, low (> min <= high/max), high (>= low/min <= max), optimum, form (связь с формой)`  
Собственные псевдоэлементы: `::-webkit-meter-bar, ::-moz-meter-bar, ::-webkit-meter-optimum-value`  
`::-webkit-meter-suboptimum-value, ::-webkit-meter-even-less-good-value`
* `<progress>` - прогресс бар в минимальной комплектации  
Атрибуты `max, value`  
Собственные псевдоэлементы: `::-moz-progress-bar, ::-webkit-progress-bar, ::-webkit-progress-value`
* `<canvas>` - растровый холст для 2D/3D графики  
В целях доступности внутрь `<canvas>` помещается текстовое описание.  
* `<details>, <summary>` - стандартный блок с раскрывающимся контентом (аккордеон)  
`<summary>` - заголовок аккордеона, `<details>` - интерактивный блок  
Атрибут `open` открывает аккордеон при загрузке страницы
* `<dialog>` - стандартное всплывающее окно.  
Работает в режиме всплывающего окна (без блокировки страницы), модального окна (с блокировкой)  
Атрибут `open` открывает аккордеон при загрузке страницы  
Для блокирования прокрутки страницы нужно добавить `overflow: hidden` в body  
Для резервирования места под скролл страницы добавляется `scrollbar-gutter: stable;`  
Для `<dialog>` в JS доступны методы `show/showModal, close` (или по событию `submit` изнутри формы с `method="dialog"`)  
При закрытии `<dialog>` срабатывают `cancel -> close`  
Кнопки внутри `<dialog>` могут возвращать значение при закрытии `<dialog>` в `dialog.returnValue`  

**Особенности стандартных модальных окон:**  
- доступность для скринридеров
- закрытие по Esc
- ловушка фокуса внутри текущего `<dialog>`
- возврат фокуса на элемент страницы, который был выбран до открытия `<dialog>`
- контент скрыт по умолчанию `display: none`, а при открытии перекрывает любой элемент страницы с любымм `z-index`  

Альтернатива `<dialog>` - Popover Api. Основное отличие в том, что popover не несет семантической нагрузки и не блокирует страницу  
Создание Popover: добавление атрибутов `popover` на элемент и `popovertarget` на элемент открывающий popover  
По умолчанию элемент с `popovertarget` открывает и закрывает popover, атрибут `popovertargetaction` позволяет делегировать процесс  
Значения `popovertargetaction: show/hide/toggle(по умолчанию)`  
Значения `popover: auto(по умолчанию)/manual` - клику за пределами popover не закрывает его  
Специальная директива `@starting-style` стилизует анимацию открытия.   
Свойство `overlay` внутри `transition` необходимо для всплытия из верхнего слоя
```javascript
@starting-style {
	[popover]:popover-open {
		opacity: 0;
  }
}
[popover]:popover-open {
	opacity: 1;
	transition: overlay .5s;
}
```
В JS доступны методы: showPopover/hidePopover/togglePopover

* `<style>` - инлайн стиль    	
* `<script>` - загружаемый или инлайн скрипт  
	* async - асинхронная загрузка скрипта  
	Порядок выполнения: аналог `Promise.race` (первым выполнится загруженный первее), выполняется сразу после загрузки   
	* defer - асинхронная загрузка скрипта, выполняется после разбора документа, блокируя DOMContentLoaded, пока скрипт не загрузжен  
	Порядок выполнения: в последовательности подключения в потоке.  
	Используется, если важна последовательность запуска или нужен доступ к DOM-дереву  
	* без атрибутов - синхронная загрузка  
	Порядок выполнения: в последовательности подключения в потоке сразу после загрузки
* `<template>` - шаблон HTML-кода  
Не отображается на странице (скрипты и стили не применяются)  
Доступ к шаблону осуществляется в скрипте через атрибут `content  
```javascript
<template id="template">
	<li></li>
</template>

// JS
const template = document.querySelector('#template')
const item = template.content.cloneNode(true)
```
* `<noscript>` - альтернативный контент при отключенной поддержке скриптов
* `<noindex>` - запрет индексирования содержимого для поискового робота Яндекса  
`<!‐‐noindex‐‐><!‐‐/noindex‐‐>` - исправление ошибки валидатора, т.к. тега нет в стандарте HTML  
Запрет индексирования роботами осуществляется через meta-теги, `<a rel="nofollow"></a>`, в файде `robots.txt`  

[Вернуться к содержанию](#содержание)

## 1.1.8 Глобальные атрибуты 

* `data-атрибуты` - пользовательский атрибут для хранения информации  
Используется для получения информации в JS через `dataset` или в стилях через `attr(data-атрибут)`
* `id` 
* `class`
* `contenteditable`  - делает контент элемента редактируемым (_React спамит о ненадежности в кносоли_)
* `hidden` - скрытие элемента   
	* `hidden` - скрывает элемент из области видимости и от скринридеров, но не удаляет из DOM-дерева  
	* `display: none` - вырезает элемент из DOM
	* `aria-hidden="true"` - скрывает элемент только от скринридера
	* `role="presentation"`, `role="none"` - аналогично `aria-hidden="true"`. Отлчичие - элемент не несет семантической нагрузки
	* `opacity: 0` - скрывает видимость элемента, оставляя взаимодействие и область занимаемую в DOM
	* `visibility` - аналогично opacity
* `lang`
* `dir` - направление текста
* `translate` - разрешение/запрет перевода текста браузером
* `style`
* `tabindex` - изменение порядка навигации элементов (в том числе неинтерактивных)  
`tabindex="-1"` - убирает элемент из порядка навигации
* `title` - тултип элемента (зачитывается скринридером)
* `inert` - отключает интерактивность элемента (в том числе скрывает от скринридеров). Делает недоступным для любой навигации  
В отличие от `disabled` текст внутри `inert` нельзя выделить, а атрибут можно задать любому элементу.  
Используется, когда нужно сделать загружаемую область неактивной или убрать содержимое из порядка навигации, когда открыто модальное окно  
Автоматически добавляется при открытии `<dialog>` в режиме `modal`
* `enterkeyhint` - задает клавишу для взаимодействия с экранной клавиатурой 
* `draggable` - разрешает элементу участвовать в dnd  

[Вернуться к содержанию](#содержание)

## 1.2 Метатеги

* `<meta charset="UTF-8">` - кодировка документа - 
* `<meta name="viewport" content="width=device-width initial-scale=1.0 maximum-scale=1.0 minimum-scale=1.0">` - масштабирование документа
* `<meta name="description" content="Our description">` - описание для SEO робота
* `<meta name="robots" content="index, follow">` - разрешение поисковому роботу переходить по ссылкам - 
* `<meta name="googlebot" content="index, follow">` - разрешение поисковому роботу Google переходить по ссылкам - 
* `<meta http-equiv="X-UA-Compatible" content="IE=edge">` - последняя версия для совместимости браузера 
* `<meta name="rating" content="Возрастная категория">` - возрастные ограничения
и т.д.

## 1.2.1 Open Graph

### Open Graph (Meta)

[OG generator](https://webcode.tools/open-graph-generator)
```javascript
<meta property="og:title" content="Название">
<meta property="og:description" content="Описание">
<meta property="og:image" content="URL изображения"">
<meta property="og:url" content="URL страницы">
<meta property="og:type" content="Тип контента (article/статья, product/товар, website/сайт и т.д.)">
```

### Open Graph (Twitter)

[OG generator](https://webcode.tools/open-graph-generator)
```javascript
<!-- Типы виджета: (summary - карточка с кратким описанием
   summary_large_image - карточка с кратким описанием и большой картинкой
   app - карточка для мобильных приложений
   player - карточка с воспроизведением видео/аудио 
-->
<meta name="twitter:card" content="Тип виджета">
<meta name="twitter:title" content="Название">
<meta name="twitter:description" content="Описание">
<meta name="twitter:image" content="URL изображения">
```

### Разметка VK

```javascript
<meta property="vk:image" content="URL изображения">
<meta property="vk:title" content="Название">
<meta property="vk:description" content="Описание">
<meta property="vk:url" content="URL страницы">
```

[Вернуться к содержанию](#содержание)

## 1.2.2 Favicon

[Генератор favicon](https://realfavicongenerator.net/)  

Пример генерации:
```javascript
<!-- Favicon для различных браузеров -->
<link rel="icon" href="/path/to/favicon.ico" type="image/x-icon">
<link rel="icon" type="image/png" sizes="32x32" href="/path/to/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/path/to/favicon-16x16.png">

<!-- Apple Touch Icon для устройств Apple -->
<link rel="apple-touch-icon" sizes="180x180" href="/path/to/apple-touch-icon.png">

<!-- Иконки для Android -->
<link rel="icon" type="image/png" sizes="192x192" href="/path/to/android-chrome-192x192.png">
<link rel="icon" type="image/png" sizes="512x512" href="/path/to/android-chrome-512x512.png">

<!-- Иконка для Windows -->
<meta name="msapplication-TileColor" content="#2d89ef">
<meta name="msapplication-TileImage" content="/path/to/mstile-150x150.png">

<!-- Цвет темы для мобильных браузеров -->
<meta name="theme-color" content="#ffffff">

<!-- Альтернативные иконки для других платформ -->
<link rel="manifest" href="/path/to/site.webmanifest">
```

[Вернуться к содержанию](#содержание)

# 2. CSS features

## 2.1 Базовые понятия  

Отличия адаптивного дизайна от отзывчивого дизайна в том, что адаптивный дизайн использует несколько макетов с brealpoint,   
а отзывчивый дизайн построен на гибкой сетке, которая автоматически подстраивается под размер экрана  

## 2.1.1 Специфичность 

[Калькультор специфичности](https://polypane.app/css-specificity-calculator/)  
**Специфичность** - алгоритм определения специфичности стилей
Правила взвешивания селектора по убыванию специфичности: 
1. Идентификатор (id)
2. Класс, атрибут, псевдокласс
3. Тэг, псевдоэлементы
Комбинации `+ > ~ * :where` не имеют класса  
Псевдоклассы `:is(), :has(), :not()` принимают вес наиболее специфичного селектора внутри скобок

При расчете используется алгоритм 0.0.0, где каждая цифра равна количеству селекторов из правил выше.  
Пример: `#block section > .list a` -> 1.1.2; `* .list a` -> 0.1.1

Стили в теге `style` меют больший вес по сравнению с селекторами в файле стилей.  
Инлайн стили имеют еще больший вес (использование в почтовой рассылке, React)
`!important` - модификатор максимально увеличивающий вес селектора

При любом взвешивании учитывается принцип каскада.  

### Виды селекторов  

* селекторы по тегу (используются при сбросе браузерных стилей (normalize) )
* селекторы по id
* селекторы по классу 

### Комбинированные селекторы  

* `*` - универсальный селектор соответстувует _всем_ тегам, исключая псевдоэлементы  
[Селектор *+*](https://frontender.info/axiomatic-css-and-lobotomized-owls/)
*  `[attr]` - селектор по атрибутуf
* `[attr="value"]` - селектор по атрибуту, который в точности равен `value`
* `[attr~=value]` - селектор по атрибуту, который является перечнем слов с пробелами, включающими `value`
* `[attr|=value]` - селектор по атрибуту, который в точности равен `value` или начинается с `value` и дефиса
* `[attr^=value]` - селектор по атрибуту, который начинается с `value`
* `[attr$=value]` - селектор по атрибуту, который заканчивается на `value`
* `[attr\*=value]` - селектор по атрибуту, который содержит `value`
* `[attr operator value i]` - `i` - позволяет не учитывать регистр значения атрибута
* `.element1, .element2` - селектор группировки
* `.class1.class2` - селектор объединения
* `.element1 .element2` - селектор потомока
* `.element1 > .element2` - селектор вложенного элемента (потомок первого уровня)
* `.element1 + .element2` - селектор соседнего элемента  
```javascript
label + input { }

<input>
<label>Лейбл</label>
<input> // cтиль применится к данному элементу
<input>
```
* `.element1 ~ .element2` - селектор одного уровня вложенности  

[Вернуться к содержанию](#содержание)

## 2.1.2 Принцип каскада 

**Принцип каскада** - приоритет стиля зависит от положения в каскаде, специфичности и область видимости  
Среди стилей с одинковым весом наибольшим приоритетом обладает стиль ниже всех по каскаду.  

Уровни каскада(по убыванию важности):
1. Стили во время CSS переходов (transition)
2. Браузерные стили с `!important`
3. Пользовательские стили с `!important`
4. Авторские стили с `!important`
5. Стили во время анимации
6. Обычные (без `!important`) авторские стили
7. Обычные пользовательские стили
8. Обычные браузерные стили

Атрибут `style` применяет стили только к выбранному элементу (область видимости стиля) 

**Глобальные ключевые слова**
* initial - сброс стиля к начальному значению, до изменения стиля разработчиком/браузером  
_например у блока `<div>` свойство display сбросится до `display: inline`_.
* inherit - наследование любого свойства родителя (наследуемого и ненаследуемого)
* unset - если свойство наследуемое, то применяется inherit, если ненаследуемое, то initial
* revert - в зависимост от источника стилей 
	* браузерные стили - Unset
	* пользовательские стили -> браузерные стили
	* авторские стили -> пользовательские стили
	
Свойство `all` - сброс всех стилей элемента, кроме direction и unicode-bidi  

[Вернуться к содержанию](#содержание)
	
## 2.1.3 Наследование  

[Список наследуемых свойств](https://www.w3.org/TR/CSS22/propidx.html)  
**Наследование** - способность элементов перенимать стили родительских элементов  
Наследуемыми стилями являются: 
- свойства шрифта
- межбуквенные, межсловные расстояния
- параметры текста, оформление  
- пунктов списка 
- вид курсора  

Наследуемость проявляется на любом уровне вложенности потомка относительно родителя  
Ключевое слово `currentColor` позволяет наследовать свойство с цветом от родительского элемента у ненаследуемых свойств  

[Вернуться к содержанию](#содержание)

## 2.1.4 Контекст наложения  

**Контекст наложения** - правила определения `z` координаты элемента  
Положение по координате `z` изменяется свойством `z-index`  
Элементы в отдном контексте наложения расположены тем выше, чем они ниже в потоке

Новый контекст наложения формируется:
1. Корневым элементом `html`  
2. Абсолютным `absolute` или относительным `relative` позиционированием при отличном от значения `auto` свойства `z-index`
3. Флекс-элементами с `z-index`
4. Элементом с `opacity` меньше 1
5. Элементом с `transform` отличным от `none`
6. Элементом с `mix-blend-mode` отличным от `normal`
7. Элементом с `filter` отличным от `none`
8. Элементом с `position: fixed`
9. Элементом с `will-change`
10. Элементом с `isloation: isolate`

_Порядок наложения_:
1. Фон `background` и рамка `border` (другой элемент нельзя спозиционировать ниже данных элементов)
2. Элемент с `z-index` меньше 0
3. Элемент с `display: block`
4. Элемент с `float`
4. Элемент с `display: inline`
5. Элемент (включая потомков) с `z-index` `auto` или 0 или с `opacity: 0`
6. Элемент (включая потомков) с `z-index` больше 0
 
---

Директива **`@layer`** позволяет управлять каскадными слоями, назначая приоритет
```javascript
@layer components, states;

@layer components {
	...стили
}
```

Слои поддерживают вложенность друг в друга  
```javascript
@layer framework.base, framework.theme;

@layer framework {
  @layer base {
    ...стили
  }
```

Приоритет стилей: 
1. Слой `@layer` с `!important`
2. Стили вне `@layer`
3. Слой `@layer` без свойства с `!important`

Функция layer() - позволяет расствалять приоритет стилей совместно с подключаемыми библиотеками  
```javascript
@import url(bootstrap.css) layer(base)
@import url(buttons.css) layer(base)
```

[Вернуться к содержанию](#содержание)

## 2.1.5 Цвета в вебе  

[Преимущества OKLCH](https://web-standards.ru/articles/oklch-in-css-why-quit-rgb-hsl/)  
[Правильная настройка палитры](https://www.youtube.com/live/bPgiOkMyxJQ?si=tzi7SPlrIYfZpP1R&t=4762)  
`oklch(L C H / a)` - прогрессивный способ задания цвета, где L - яркость, C - насыщенность, H - оттенок, a - непрозрачность  
Отличие от других способов: 
* Форматы RGB и HEX - нечитаемость для человека, сложность в ручной трансформации цвета (`rgb(109 162 218), #6ea3db`)
* Формат HSL - деформирует пространство цвета в цилиндр с одинаковыми значениями насыщенности.  
В реальности глаз имеет разную максимальную насыщенность для разных оттенков  
Возникает проблеме при изменении яркости (например через darken): разные оттенки приводят к различным результатам  
При изменении оттенка может измениться яркость  
* Формат OKLAB - координатами цветового пространства являются количество красного и зеленого, что не наглядно для человека
* Формат LCH = имеет сдвиг оттенка при изменении насыщенности и яркости для голубого цвета между 270 и 330 градусами
Неподдерживаемые экранами цвета приводятся к ближайшим доступным  
Свойство `color()` - перевод цвета из одного цветового пространства в другое или установка цвета в новом формате 
`color(from grey display-p3 r g b / 0.8)` - символа канала переводит цвет без трансформации  

[Вернуться к содержанию](#содержание)

## 2.1.6 Единицы измерения

### Относительные величины: 
* em - задает величину относительно размера шрифта родительского элемента (2em для `font-size: 20px` - 40px)  
Элементы более глубокой вложенности продолжают увеличивать размер шрифта каждый относительно своего родителя  
* rem - задает величину относительно размера шрифта корневого элемента
* vh, vw - размер в процентах от вьюпорта
* vmin, vmax - размер в процентах от минимальной максимальной стороны вьюпорта  
Проблема относительных значений от размера вьюпорта:  
в десктопе скроллбар является частю вьюпорта - возникает горизонтальный скролл на размер скролл бара  
в мобильной версии не учитываются размеры адресной страки и панели навигации - контент оказывается больше видимого размера экрана
* svw, svh, svmin, svmax, lvw, lvh, lvmin, lvmax - наибольший/наименьший размер с учетом элементов браузера 
* dvh, dvw, dvmin, dvmax - динамический рассчет величины при открытой/закрытой адресной строке и навигационной панели  
* другие форматы  

### Абсолютные величины:  
Величины задаются в px, cm, in, mm и т.д.  
Углы в deg, grad, rad, turn.  
Время в ms, s.  

С точки зрения доступности единицы em, rem предпочтительнее, т.к. динамически изменяются в зависимости от пользовательские размеры шрифта
Альтернативно для динамического изменения размеров в абсолютных величинах: [Clamp-генератор](https://clamp.font-size.app/?config=eyJyb290IjoiMTYiLCJtaW5XaWR0aCI6IjUwMHB4IiwibWF4V2lkdGgiOiI5MDBweCIsIm1pbkZvbnRTaXplIjoiMTZweCIsIm1heEZvbnRTaXplIjoiNDhweCJ9)  
Ограничение: работает только с изменением от большего к меньшему

[Вернуться к содержанию](#содержание)

## 2.2 Псевдоклассы

**Псевдокласс** - селектор уточняющего состояния элемента

* `:link` - стиль непосещенных ссылок (объединяет `<a>` и `<area>` с атрибутом `href`)
* `:visited` - стиль посещенных ссылок (стили данного селектора ограничены из соображений безопасности)
* `:hover` - стиль элемента при наведении курсора (не работает на тач-устройствах)  
Для обнуления стилей на тач устройствах используется: `@media (any-hover: hover) { }` для исключения залипания
* `:active` стиль нажатого элемента
* `:focus` - стиль элемента в фокусе (для взаимодействия через клавиатуру нельзя полностью обнулять стили фокуса) 
* `:focus-visible` - стиль элемента в фокусе при взаимодействии _только_ через клавиатуру
* `:focus-within` - стиль элементов в фокусе или имеющих дочерние элементы в фокусе
Последовательность приоритета псевдоклассов link -> visited -> focus -> hover -> active
* `:target` - стиль якорного элемента
* `child-група` - стиль элементов по порядковому номеру внутри родительского
	* `:first-child` - первый дочерний элемент
	* `:last-child` - последний дочерний элемент
	* `::nth-child(n)` n-ные дочерний элемент (разрешены формулы с целочисленным результатом)
	* `:nth-last-child(n)` - n-ные дочерний элемент с конца (разрешены формулы с целочисленным результатом)
	* `:only-child` - единственный дочерний элемент
	* `:nth-child(odd)` - нечетные дочерние элементы
	* `:nth-child(even)` - четные дочерние элементы
	* `:` - 
* `type-группа` - стиль элементов одного типа по порядковому номеру
	* `:first-of-type` - первый элемент данного типа
	* `:last-of-type` - последний элемент данного типа
	* `:nth-of-type(n)` - n-ные элемент данного типа (разрешены формулы с целочисленным результатом)
	* `:nth-last-of-type(n)` - n-ные элемент данного типа с конца (разрешены формулы с целочисленным результатом)
	* `:only-of-type` - единственный элемент данного типа
	* `:nth-of-type(even)` - нечетные элементы данного типа
	* `:nth-of-type(odd)` - четные элементы данного типа
* `:not(X)` - отрицание элементов условия X (пример: `li:not(:last-child) { }` - все кроме последнего)  
**Нельзя** использовать отрицание с псевдоэлементами
* `:checked` - стиль выбранных чекбоксов и радиокнопок
* `:disabled` - стиль отключенного элемента
* `:empty` - стиль пустых элементов (без потомков или текста)  
Используется для отключения видимости элементов с изменяемым наполнением при наличии в них  отступов
* `:has()` - стиль родительского элемента на основе дочернего  
Пример: `a:has(img)` - применится ко всем ссылкам, которые имеют дочерним изображене
* `:is()` - выбор нескольких селекторов без перечисления через запятую  
Пример: `:is(header, main, footer) p:hover { }` - стиль применен к параграфам header, main, footer  
_Ограничение_: нельзя применять к псевдоэлементам
* `:where()` - аналогично `:is`, но без учета специфичности селекторов в скобках
* `:in-range, :out-of-range` - стиль полей ввода с заданными атрибутами min/max
* `:required, :optional` - стиль обязательных/необязательных к заполнению полей
* `:invalid, :valid` - стиль ошибочно/корректо заполненного поля  
* `:user-valid, :user-invalid` - аналог `:invalid, :valid` с решенной проблемой применения псевдокласса до начала взаимодействия пользователя с элементом  
>_Отличие `:invalid, :valid` от `:user-valid, :user-invalid`. Псевдоклассы `:invalid, :valid` срабатывают в момент ввода или при первоначальной загрузке при отсутствии заполнения в полях `required`  
* `:placeholder-shown` - стиль элементов с атрибутом `placeholder`, когда поле не заполнено  
_Стиль применяется к самому полю, а не `placeholder`_
* `:default` - стиль выбранных элементов по умолчанию (selected)
* `:lang(), :dir()` - стиль элементов по языку/направлению текста
* `:root` - самомтоятельный селектор корневого элемента HTML/SVG (Используется для записи глобальных переменных css)
* `:indeterminate` - стиль неопределенного состояния (когда пользователь не выбрал ни один из предложенных вариантов)  
Используется в чекбоксах, радиокнопках и прогресс барах
* `:fullscreen` - стиль документа в полноэкранном режиме
* `:read-write` - стиль полей ввода, в которые можно ввести данные (`<input>, <textarea>`, элементы с contenteditable)
* `:read-only` - стиль полей ввода с атрибутом readonly (`<input>, <textarea>`, элементы с contenteditable)

[Вернуться к содержанию](#содержание)

## 2.3 Псевдоэлементы

* `::before, ::after` - псевдоэлемент самый первый/последний потомок. Обязательное свойство `content`
Для улучшения доступности можно добавить текстовое описание элемента через `/` - `content: "ⓘ" / "Описание"`  
В ссылочных элементах не требуется описание, так как возникает конфликт при озвучивании  
Зарезервированные значения контента: open-quote, close-quote, no-open-quote, no-close-quote  
Можно использовать attr() со значениями data-атрибутов, текст, символы, изображения  
Можно использовать counter
```javascript
.benefits {
  counter-reset: benefits;
}
.benefits-item {
  counter-increment: benefits;
}
.benefits-item::before {
	content: counter(benefits);
}
```
* `::placeholder` - псевдоэлемент подсказки в текстовом поле
* `::first-letter` - псевдоэлемент первой буквы первой строки блочного элемента
* `::first-line` - псевдоэлемент первой строки текста блочного элемента  
_Строка динамически зависит от размеров блока_
* `::selection` - псевдоэлемент пользовательского выделения текста (например мышью)
* `::marker` - псевдоэлемент буллитов списка (элементов с `display: list-item`)  
Приоритет маркера: свойство content, list-style-image, list-style-type
* `::backdrop` - псевдоэлемент положки под элементами всплывающими на верхний слой (`<dialog>, <popover>, <video> в полноэкранном режиме`

[Вернуться к содержанию](#содержание)

## 2.4 Анимации и Переходы

Анимация создается директивой `@keyframes`. Обязательно наличие названия анимации `@keyframes blink { }`  
Для создания анимации необходимо указать минимум 2 ключевых кадра. Кадрый задаются в % или через ключевые значения(from/to)  
* `animation-name` - имя анимации из директивы
* `animation-duration` - длительность одного цикла анимации
* `animation-iteration-count` - количество повторений анимации (infinite или число) 
* `animation-direction` - направление анимации  
	* normal - воспроизведение от начала до конца, затем с начального кадра (скачок в анимации) 
	* reverse - воспроизведение от конца к началу, затем с последнего кадра (скачок в анимации)
	* alternate - каждый нечетный повтор воспроизводится в прямом порядке, а нечетный в обратном
	* alternate-reverse - инвертированный alternate
* `animation-timing-function` - плавность анимации  
Имеет ключевые значения: linear, ease(по умолчанию), ease-in, ease-out, cubic-bezier (функция на основе кривой Безье)  
[Генератор кривой Безье](https://cubic-bezier.com/#.17,.67,.83,.67)  
step-start, step-end - пошаговые анимации с изменениями в начале/конце  
steps(stepCount, stepPos) - кастомная пошаговая анимация, где   
stepCount - количество шагов анимации, stepPos - момент начала анимации  
[визуальное объеянение отличий](https://danielcwilson.com/blog/2019/02/step-and-jump/)
	* start - поведение как у step-start
	* end  - поведение как у step-end 
	* jump-start - пропуск начальной позиции
	* jump-end - пропуск последней позиции
	* jump-none - учитывает первую и последнюю позиции (если начальная, конечная позиция совпадает - удваивает время нахождения в ней)
	* jump-both - пропуск первой и последней позиции
* `animation-delay` - задержка воспроизведения (отрицательное значение начнет анимацию за кадром)
* `animation-play-state` - пауза/воспроизведение анимации (running/paused)
* `animation-fill-mode` - применение ключевых кадров до/после проигрывания  
	* none - по умолчанию
	* forwards - после окончания анимации применится последний кадра
	* backwards - после окончания анимации применится первый кадр
	* both - до начала анимации применен первый калр, после конца последний  
Шрткат для всех свойств анимации: `animation`. Порядок значений не важен. Первое значение времени - длительность.  
К одному элементу можно применять несколько анимаций

---

**Transition** - плавные переходы
* `transition-property` - изменяемое свойство (all - все свойства)
* `transition-duration` - длительность перехода
* `transition-timing-function` - функция скорости
* `transition-delay` - задержка
Шорткат для всех свойств перехода - `transitoin(property duration timing-function delay) ` 
Для перехожов предпочтительно использовать opacity, transform, т.к. они не вызывают Layout и Paint
Для настройки разной скорости в прямом и обратно направлении нужно указать свойство transition в базовом и измененном состоянии
Где скорость перехода в состоянии указывается на самом состоянии (на базовом - скорость перехода в базовое состояние)

Свойство `will-change()` заренее сообщает браузеру какой элемент будет изменяться - повышение производительности.  
* auto - по умолчанию
* scroll-position - изменения положения при скролле
* contents - изменение содержимого элемента
* конкретное свойтсво
Большое количество will-change заставляет отслеживать слишком много элементов, что ведет к снижению производительности  
Свойство включается до изменения в самом элементе (например при наведении на родителя подключаем свойство на потомке)  
После прекращения изменений свойство рекомендуется отключать, дли прекращения отслеживания (JS)

[Вернуться к содержанию](#содержание)

## 2.5 Размеры, позиционирование и трансформации 

Блочный элемент по умолчанию занимает всю ширину родителя, а высота подстраивается под контент.  
Строчный/строчно-блочный элемент по умолчанию подстраивают ширину и высоту под вложенный контент.

* display` - тип элемента (none, block, inline, inline-block, flex, inline-flex, grid, inline-grid, list-item)
* `width, max-width, min-width`
* `height, max-height, min-heihgt`  
Для поддержки доступности используют `inline-size` и `block-size` направления
* `aspect-ratio` - соотношение сторон (w/h) 
```javascript
width: 50px;
aspect/ratio: 1/1;
```
* padding, margin  
Свойство `margin` в вертикальном направлени НЕ складывается, а принимает значение наибольшего значения.
Для исправления данного поведения нужно: 
	* задать родителю `padding` в месте выпадения отступа.
	* задать родителю border (например transparent) в месте выпадения отступа
	* задать родителю `overflow: visible`
	* задать родителю `display: flex/grid` 
`margin: 0 auto` - выравнивание по центру горизонтальной оси  
Верхний и нижний внешний отступ  не работает для строчных элементов  
* `box-sizing` - изменение рассчета размеров элемента (border-box - включает границы и отступы)  

### Calc  

[Руководство по calc](https://habr.com/ru/companies/ruvds/articles/493660/)  
* `calc()` - функция математических вычислений
* `min(), max(), clamp()` - минимальное/максимальное/значение в диапазоне  
`min(10dvh 100px)` - высота составит 10% от вьюпорта, но не более 100px  
`clamp(min, optimal, max)` -  используется оптимальное значение, пока не выходим за диапазон минимального и максимального  
* `round(type, value, interval)` - функция округления, где:
	* Необязательный параметр `type`. Принимает значения:  
		* up - аналог Math.ceil
		* down - аналог Math.floor
		* nearest (по умолчанию) - аналог Math.round
		* to-zero - аналог Math.trunc
	* Необязательный параметр `interval` - шаг округления. `round(0.23, 0.1) // 0.2`
[New CSS Math: round()](https://danielcwilson.com/posts/mathematicss-round/)
* `mod(dividend, divisor), rem(dividend, divisor)` - остаток от деления (аналог %)  
`mod` - сохраняет знак divisor, `rem` - сохраняет знак dividend
---

* `position` - позиционирование элемента
	* static - значение по умолчанию. Элемент в нормальном потоке документа
	* relative - элемент занимает столько же места как и при static, но визуально может быть смещен от начального положения  
	Влияет на появление скролла, если смещен за границы родителя
	* absolute - элемент вырезается из основного потока. Позиционируется относительно ближайшего родителя с relative  
	Ширина определяется шириной контента, к элементу применяется блочная модель
	* fixed - позиционирование относительно окна браузера (или относительно элемента с tranform, filter или perspective) 
	* sticky - позиционируется в нормальном потоке (как static) но при скролле родителя ведет как relative и fixed  
	inset свойсва задают положениие элемента относительно родителя имеющего скролл  
При относительном позиционировании **необходимо задавать смещение**
* `top, left, right, bottom` - смещение элемента при позиционировании (свойства без accessibility)
* `inset` - смещение элемента при позиционировании (с поддержкой accessibility)  
Шорткат для `inset-inline-start/end`, `inset-block-start/end`.  
`inset: 0` позволяет задать позиционирование по всей ширине элемента относительно которого идет смещение

---

**Свойства трансформации** - `translate, rotate, skew, scale, matrix, perspective`
В свойстве `transform` можно объединить функции трансформации (аналогичны свойствам) или применить к конкретной оси  
**Пример:** `translateX (1 ось), scale (2 оси), skew3d (все три оси)`  
* `perspective` - добавляет перспективу для примененных функций трансформации по оси z, _должна применяться раньше остальных функций_  
* `perspective-origin` - координата точки схода 3D-пространства  
*  `backface-visibility` - управляет видимостью задней части элемента (visible/hidden)  
При использовании свойства `transform` на результат влияет порядок применяемых функций  
При использовании отдельных функций результат всегда одинаковый

* `transform-origin` - координата точки относительно которой применяются трансформации (0, 0) - верхний левый угол  
Ключевые значения: top, left, right, bottom  
`center` - по умолчанию  
Только числовое значение - смещение по Х, только ключевое значение (кроме center) - смещение по Y при X = center
* `transform-style` - поведение потомка в 3D (preserve-3d - назависимая плоскость в 3D, flat - плоскость родителя - по умолчанию)
* `transform-box` - область применения трансформации 
	* content-box - область содержимого элемента без учета отступов и границ
	* border-box - область содержимого элемента включая отступы и границы
	* fill-box - область всего элемента (для svg)
	* stroke-box - область контура (для svg)
	* view-box - область viewbox (для svg)

[Вернуться к содержанию](#содержание)
	
## 2.6 Фон

* `background-color` - заливка фона одним цветом (является фолбеком для background-image)
* `background-image` - фоновое изображение или градиент  
Можно задавать несколько фоновых картинок. Самой верхней станет - первая в списке.  
[Принцип цикады](https://habr.com/ru/articles/117160/)
* `background-position` - положение фонового изображения (Ключевые значения: center, bottom, left, right доступны к объединению)  
По умолчанию верхний левый угол
* `background-repeat` - повтор фонового изображения (repeat, repeat-x, repeat-y, none, space, round)  
space - повторение с равным расстоянием между изображениями  
round - повторение изображения целого количества раз с масштабированием
* `background-size` - изменение размера фонового изображения  
cover - масштабирование с сохранением пропорций с заполнением всей доступной площади с обрезкой изображения за границами элемента   
contains - масштабирование с сохранением пропорций так, чтобы изображение вписалось в размер элемента
* `background-attachment` - прокрутка фона вместе со страницей (применяется для параллакса) 
fixed - не прокручивается  
local - зависит от поведения элемента (будет прокручиваться при скролле элемента)  
scroll - фон перемещается вместе с содержимым элемента
* `background-clip` - обрезка фонового изображения (border-box, padding-box, content-box, text)
* `background-origin` - позиция фонового изображения (border-box, padding-box, content-box)
* `background-blend-mode` - смешивание разных фонов (background-color и background-image) между собой  
Шорткат для свойств фона `background`. Свойства записываются в любом порядке, кроме `position / size`.
* `object-fit` - аналог `background-size` для тегов `<img>, <picture>, <video>`  
	* fill - изображение помещается целиком без учета собственных пропорций (по умолчанию)
	* contain - изображение помещается целиком с учетом собственных пропорций
	* cover - изображение заполняет доступную область с учетом собственных пропорций, обрезая лишнее за пределами границ
	* none = без изменений пропорций или размеров
	* scale-down - браузер выбирает автоматически между none и contain
* `object-position` - аналог `background-posituion` для тегов `<img>, <picture>, <video>`. Применяется при наличии `object-fit`

---

* `linear-gradient([rotation] [spread] [position], ...colors)` - линейный градиент, где  
rotation - поворот градиента, по умолчания сверху вниз (ключевые значения: to top, to bottom, to left, to right)  
colors - количество цветов в последовательности неограничено (`color[[ startPos] endPos]`)
Для цвета можно задать начальную и конечную точка цвета. При совпадении точек в соседних цветах переход будет жестким  
Для совместимости со всеми браузерами transparent задается в hex/rgb/других форматах без ключевого слова
* `repeating-linear-gradient()` - повторение линейного градиента (параметры аналогичны linear-gradient)
* `radial-gradient([shape], ...colors)` - радиальный градиент  
shape - форма градиента circle(по умолчанию)/ellipse
center - положение центральной точки (ключевые значения at left, at top, at right, at bottom, at center(по умолчанию))  
Ключевые слова можно совмещать (at top left)  
Альтернативно положение центральной точки задается в % или px (at 20% 50% или at 20px 10px)  
spread - распротранение градиента (ключевые значения: closest-side, farthest-side, closest-corner, farthest-corner)
* `repeating-radial-gradient()` - повторение радиального градиента (параметры аналогичны radial-gradient)  
По умолчания форма градиента - ellipse
* `conic-gradient([startPos] [center], ...colors)` - конический градиент  
startPos = начальный угол (по умолчанию 12 часов)
center - смещение позиции центра градиента
* `repeating-conic-gradient()` - повторение конического градиента (параметры аналогичны conic-gradient)
_К элементу можно применять одновременно несколько градиентов_

---

* filter - применяет функции фильтров: blur, brightness, contrast, drop-shadow, grayscale, hue-rotate, invert, opacity, saturate, sepia  
drop-shadow в отличие от box-shadow учитывает альфа-канал (тень не будет прямоугольной)  
Одновременно можно применять несколько фильтров
* `mix-blend-mode` - алгоритм смешивания цвета элемента с расположенными ниже элементами
* `backdrop-filter` - применение фильтра к фоновому изображению под элементом с данным свойством  
* `image-rendering` - задает способ интерполяции при изменении изображения
* `image-set()` - перечисление нескольких вариантов фоновых изображений с media выражениями (аналогично `<picture>`)  
В Chrome и Safari нельзя указать тип
```javascript
background-image: image-set(
	url("image@1x.webp") type("image/webp") 1x,
	url("image@2x.webp") type("image/webp") 2x,
	url("image@1x.png") type("image/png") 1x,
	url("image@2x.png") type("image/png") 2x
}
```

* `fill` - цвет заливки svg
* `stroke` - цвет обводки svg

[Вернуться к содержанию](#содержание)
	
## 2.7 Текст

`@font-face` - подключение шрифтов. Обязательные свойтсва `font-family` и `src`  
Шрифты указываются в последовательности от более нового формата к старому. local - ищет шрифт установленный локально пользователем
```javascript
@font-face {
  font-family: "Helvetica";
  src: local("Helvetica Regular"),
    url("Helvetica-webfont.woff2") format("woff2"),
    url("Helvetica-webfont.woff") format("woff"),
    url("Helvetica-webfont.svg") format("svg");
    url("Helvetica-webfont.ttf") format("truetype");
    url("Helvetica-webfont.otf") format("opentype");
  font-weight: 500;
}
```

* `font-family` - семейство шрифтов текста  
Количество колбеков: `font-family: "PT Sans", "Arial", sans-serif;` может быть любым (Используются для исключения ошибок со шрифтами)  
Элементы `<input>, <button>, <textarea>, <select>` не наследуют семейство шрифтов от родителя  
serif - с засечками, sans-serif - без засечек, monospace - моноширный, cursive - курсивный, fantasy - декоративный, system-ui - системный  
* `font-size` - размер шрифта  
**Строчные элементы в потоке имеют между собой отступ при переносе строки**   
Для устранения отступа нужно добавить в корневой элемент `font-size: 0;`
* `font-style` - начертание шрифта: normal, bold, italic, oblique(наклонный- используется при отсутствии курсивного начертания)
* `font-weight` - толщина шрифта 
* `font-variant` - управления свойствами вариативного шрифта
* `font-stretch` - начертание шрифта (нормальное, сжатое, расширенное, в процентах)
* `line-height` - межстрочный интервал
`font` - шорткат для всех свойств выше (обязательные значения font-size и font-family).  
Все неуказанные свойтва сбросятся до стандартных. 
* `font-display` - отображение шрифта во время загрузки (используется внутри дескриптора @font-face)  
При первом рендере браузер рассчитывает место для текста исходя из шрифта в фолбеке   
Если шрифт не загружен к моменту отображения страницы запускается временная шкала загрузки, которая состоит:
	* период блокировки - текст невидим
	* период замены - текст отображается запасным шрифтом
	* период сбоя - помечает не загруженный шрифт как неудачный и использует запасной
Ключевые значения определяют длительность периодов:  
[График объясняющий разницу](https://blog.sentry.io/web-fonts-and-the-dreaded-cumulative-layout-shift/)  
	* auto - определяется браузером
	* block - короткий период блокировки (3с) и бесконечный период замены  
	* swap - короткий период блокировки (100мс) и бесконечный период замены  
	* fallback - короткий период блокировки (100мс) и короткий период замены (3с)
	* optional - короткий период блокировки (100мс) и нулевой период замены
* `color` - цвет текста  
[Проверка контрастности текстов на фоне](https://www.siegemedia.com/contrast-ratio)
* `text-align` - горизонтальное выравнивание текста (Также выравнивает строчные, строчно-блочные элементы: например `<img>`)
* `text-justify` - тип выравнивания при заданном свойстве `text-align`  
(inter-word - пробелы между словами, inter-character - пробелы между символами)
* `vertical-align` - вертикальное выравнивание текста (Применияется для выравнивания изображений относительно текста)  
Ключевые значения: top, middle, bottom, baseline, text-top, text-bottom, sub, super  
_Поддерживает числовые значения._ Применияется к **выравниваемому элементу**
* `text-transform` - трансформация букв в тексте (uppercase, lowercase, capitalize)
* `text-decoration-line` - декоративная линия (underline, line-through, overline) Значения можно комбинировать
* `text-decoration-style` - стиль декоративной линии (solid, doublem dotted, dashed, wavy)
* `text-decoration-color` - цвет декоративной линии (По умолчанию `currentColor`)
`text-decoration` - шорткат для 3 свойств выше.  
**Толщиной и расстоянием от текста управлять нельзя** Для этого используются псевдоэлементы или границы  
**Поддержка 95%**
* `text-decoration-thickness` - управление толщиной декоративной линии
* `text-underline-offset` - сдвиг декоративной линии
* `text-underline-position` - положение декоративной линии (для вертикального письма)
* `text-decoration-skip-ink` - поведение линии при контакте с глифами шрифта (none - перечеркивает, all - не перечеркивает)
* `text-rendering` - позволяет включить/отключить кернинг и лигатуры
* `text-shadow` - тень букв текста (x y blur color). Можно указывать несколько теней
* `letter-spacing` - межбуквенное расстояние
* `word-spacing` - интервал между словами и тегами
* `white-space` - обработка переносов строк и пробелов в тексте  
	* normal - по умолчанию, игнорирование форматирования
	* nowrap - аналогично normal, но не учитываются границы элемента
	* pre - сохраняется форматирование в HTML (включая переносы строк и пробелы), границы элемента не учитываютсяё
	* pre-wrap - аналогично pre, но с учетом границ элемента
	* pre-line - аналогично pre, но подряд идущие пробелы схлопываются
	* break-spaces - аналогично pre-wrap, но подряд идущие пробелы на границе элемента переносятся в равной степени
* `overflow-wrap` - управление переносом длинных слов при переполнении элемента  
	* normal - слова не переносятся
	* break-word - слова разбиваются в месте границы элемента (мягкий перенос не учитывается)
	* anywhere  - аналогично break-word, но с учетом мягкого переноса
* `hyphens` -  перенос слов через дефис при переполнении элемента
	* none - не разрываются
	* manual - разрывается в местах переносов
	* auto - браузер определяет автоматически  
	Символы переносов: `&hyphen;` (символ переноса даже при отсутствии разрыва), `&shy;` (мягкий перенос) 
* `quotes` - тип кавычек `quotes: "«" "»" "„" "“";`  
Открывающая, закрывающая внешние кавычки, открывающая, закрывающая вложенные кавычки
* `text-indent` - отступ первой строки (hanging - отступы во всех строках кроме первой, each-line - инвертированный hanging)  
Поддерживает числовые значения
* `writing-mode` - изменяет направление текста (для вертикальных языков) 
* `text-orientation` - тип отображения при свойстве `writing-mode` не `horizontal-tb`  
mixed - повернуты на 90deg, upright - друг под другом
* `text-overflow` - тип обрезки текста при переполнении элемента (clip - обрезка по краю, ellipsis - многоточие)
* `text-size-adjust` - позволяет увеличивать шрифты на мобильных экранах (auto  - по умолчанию, none - отключено)  
Поддерживает процентное значение
* `tab-size` - длина табуляции (в пробелах, в условных единицах)

[Вернуться к содержанию](#содержание)

## 2.8 Границы

* `border-style` - стиль рамки элемента (none, solid, dotted, dashed, double, groove, ridge, inset, outset)
* `border-color` - цвет рамки элемента
* `border-width` - толщина рамки элемента  
`border` - шорткат для рамки свойств. Свойство поддерживает логические оси block/inline  
_Если рамка прозрачная, то сквозь нее будет видет фон (поведение по умолчанию) `background-clip` позволяет обрезать фон_  
С помощью рамки можно создавать декоративные элементы (треугольники, галочки) [генератор](https://www.cssportal.com/css-triangle-generator/)
* `border-image-source` - изображение или градиент
* `border-image-slice` - размер фрагмента в пикселях. Дополнительно ключевое значение `fill` заполняет центр
* `border-image-repeat` - способ заполнения рамки (stretch, round, space, repeat)  
* `border-image-width` - ширина рамки
`border-image` - шорткат для предыдущих 4 свойств. 
Изображение делится на 9 частей: 4 угла, 4 стороны, центр. Стандартно отображаются только углы.  
* `border-image-outset` - смещение рамки  
* `border-radius` - радиус фаски  
Любое из свойств является шорткатом для каждой из 4 сторон
* `border-collapse` - отображение границ ячеек таблицы (collapse - объединяет соседние границы, separate - отображает отдельно)
* `border-spacing` - отступ между границами ячеек таблицы (работает при `border-collapse: separate`)

---

* `outline-color` - цвет обводки элемента
* `outline-style` - стиль обводки элемента (none, solid, dotted, dashed, double, groove, ridge, inset, outset)
* `outline-width` - толщина обводки элемента  
`outline` - шорткат предыдущих свойств. В отличие от границы для обводки нельзя задать свойство для конкретной стороны
* `outline-offset` - смещение обводки элемента

---

* `column-count` - количество колонок контейнера
* `column-width` - длина колонки контейнера (auto - длина определяетя на основе количества колонок)
Если заданы оба свойства, то браузер: 
1. Длина контейнера больше длины всех колонок: длина колонок увеличивается пропорционально свободному пространству  
2. Длина контейнера кратна длине колонки: отрисуется `длина контейнера / длина колонки` количество элементов
3. Длина контейнера < длине колонки: весь контент отрисовывается в 1 колонку на всю ширину контейнера  
`columns` - шорткат для предыдущих свойств
* `column-fill` - управление разделения на колонки в контейнере с фиксированной высотой  
	* balance - по умолчанию делит на равное количество колонок с равным заполнением
	* auto - заполняет колонку контентом, пока не произойдет полного заполнения
* `column-span` - растягивание элемента на несколько колонок (none, all). До и после элемента появляются переносы  
Контент до и после растянутого элемента делится на колонки независимо
* `column-rule-color` - цвет линии между колонками
* `column-rule-style` - тип линии между колонками (solid, dotted, dashed, double, groove, ridge, none)
* `column-rule-width` - ширина линии между колонками  
`column-rule` - шорткат для 3 предыдущих свойств

---

* `box-shadow` - тень элемента (x y blur spread color)  
Ключевое слово inset делает тень внутренней  
Свойство поддерживает множественную тень [Примеры](https://habr.com/ru/companies/microsoft/articles/136057/)

[Вернуться к содержанию](#содержание)

## 2.9 Flex

Flex-контейнеры имеют 2 оси. Основная - вдоль расположения элементов, поперечная - перпендикулярно основной.  
`inline-flex` - изменяет внешнее поведение на строчное.  

* `flex-direction` - управление направлением основной и поперечной оси (row, column, row-reverse, column-reverse)
* `flex-wrap` - перенос flex-элементов  
nowrap - при переполнении остаются в одном ряду, wrap - переносятся в новый ряд,  
wrap-reverse - элементы располагаются наоборот относительно основной оси, поперечная сохраняет направление  
```
wrap  | wrap-reverse
1 2 3 | 4 5 
4 5   | 1 2 3
```
`flex-flow` - шорткат для flex-direction и flex-wrap
* `justify-content` - выравнивание флекс-элементов относительно основной оси  
	* flex-start/start - элементы выстраиваются от начала основной оси (start учитывает направление чтения)
	* flex-end/end - элементы выстраиваются от конца основной оси (end учитывает направление чтения)
	* center - по центру основной оси
	* space-between - крайние элементы прижимаются к краям, оставшиеся располагаются с одинаковыми отступами друг от друга 
	* space-evenly - свободное место равномерно распределяется между элементами и границами контейнера
	* space-around - свободное место равномерно распределяется между элементами; между границами и элементов - половина данного растояние
* `align-items` - выравнивание флекс-элементов относительно поперечной оси
	* stretch - элементы растягиваются вдоль поперечной оси
	* flex-start/start - элементы выстраиваются от начала поперечной оси (start учитывает направление чтения)
	* flex-end/end - элементы выстраиваются от конца поперечной оси (end учитывает направление чтения)
	* center - по центру поперечной оси
	* baseline - по базовой линии текста (нижний край шрифта, без учета выносных элементов)
* `align-content` - выравнивание рядов флекс-элементов относительно поперечной оси  
stretch, flex-start/start, flex-end/end, center, space-between, space-evenly, space-around
* `gap` - отступы между строками и столбцами. Шорткат для row-gap и column-gap
* `order` - изменяет порядок отображения элементов внутри контейнера. Без изменения структуры DOM  
Скринридеры продолжают читать в том же порядке, что и элементы в DOM.  
По умолчанию `order: 0` для всех элементов флекс контейнера
* `flex-grow` - определяет в каких пропорциях элементы увеличивают свои размер при наличии свободного пространства в контейнере 
Пример: element1 заберет в два раза больше свободного пространства, чем element2. По умолчанию - 0.
```javascript
.element1 {flex-grow: 2}
.element2 {flex-grow: 1}
```
[Как работает flex-grow](https://medium.com/p/557d406be844 "vpn")  
```
Задача:  
Ширина контейнера: 900px  
Ширина element1: 99px  
Ширина element2: 623px  
	1. Свободное место = 900 - (99 + 623) = 178px
	2. Размер flex-grow элемента = 178 / 3 = 59.33px
	3. Итоговый размер element1 = 99 + 59.33 * 2 = 218px
	4. Итоговый размер element2 = 623 + 59.33 х 1 = 682px
```
* `flex-shrink` - определяет в каких пропорциях элементы уменьшают свои размеры при переполнении контейнера  
По умолчанию - 1. 
[Как работает flex-shrink](https://medium.com/@stasonmars/%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-flex-shrink-%D0%B2-css-%D0%BF%D0%BE%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%BE%D0%B5-%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE-c41e40767194 "vpn")  
```
Задача:  
Ширина контейнера: 500px  
Ширина element1: 150px flex-shrinK: 1  
Ширина element2: 200px flex-shrinK: 2  
Ширина element2: 300px flex-shrinK: 3  
	1. Переполнение = 500 - (150 + 200 + 300) = -150px
	2. Общий вес: 1 * 150 + 2 * 200 + 3 * 300 = 1450
	3. Сокращение element1 = 150(переполнение) * 1 * 150(ширина) / 1450 = -15.5px
	4. Сокращение element2 = 150 * 2 * 200 / 1450 = -41.4px
	5. Сокращение element3 = 150 * 3 * 300 / 1450 = -93.1px
	6. Итоговый размер element1 = 150 - 15.5 = 134.5px
	7. Итоговый размер element2 = 200 - 41.4 = 158.6px
	8. Итоговый размер element3 = 300 - 93.1 = 206.9px
```
* `flex-basis` - размер элемента до того как свободное место будет перераспределено (Имеет больший приоритет, чем width/height)
`flex` - шорткат для `flex-grow`, `flex-shring`, `flex-basis`
* `align-self` - изменение выравнивания по поперечной оси иначе, чем у родительского контейнера

[Вернуться к содержанию](#содержание)

## 2.10 Grid

[All in one](https://css-tricks.com/snippets/css/complete-guide-grid/#prop-grid-template-areas)  
[Хорошая статья про css grid](https://css-live.ru/css/zolotaya-rybka-css3-grid-layout.html)  
**Грид-сетка** состоит из **грид-ячеек**, разделенных **грид-линиями**  
**Грид-область** - несколько ячеек. **Грид-линия** - ряд или колонка  
_Грид-сетка позволяет упростить позиционирование элементов при двумерной компоновке. Во всех остальных случаях применяется flex_  
`inline-grid` - изменяет внешнее поведение на строчное  
Для размеров грид-линий можно использовать единицу измерений `fr` - пропорциональный размер  
Для размеров используются ключевые слова `min-content`, `max-content`, `fit-content()` и функция `minmax`  
* min-content - минимальный размер контента
* max-content - максимальный размер без переносов и обрезки
* fit-content(value) - размер от минимального до указанного в value, где  
`fit-content(max-content)` эквивалентно `minmax(auto, max-content)`, параметр auto не равен min-content и варьируется от условий  
* minmax(minValue, maxValue) - задает диапазон значений размеров элемента от минимального до максимального  
Также можно использовать `minmax(min-content, max-content)`  
[Использование min-content, max-content и fit-content](https://webformyself.com/min-content-max-content-i-fit-content-v-css/)  
[How to Use minmax()](https://www.hongkiat.com/blog/css-grid-layout-minmax/)  

---

* `grid-template-columns, grid-template-rows` - размеры и количество столбцов/рядов грид-сетки  
`grid-template-rows: 250px 150px 50px;` - 3 ряда с размерами 250, 150 и 50  
`grid-template-rows: 1fr 2fr` - 2 ряда с размерами 1/3 и 2/3 свободного пространства грид-линии  
`grid-template-columns: [start line1] 50px [line1] 100px [end line3]` - именование грид-линий  
Линии могут иметь несколько имен. Именование в `[]`  
`grid-template-columns: repeat(3, 50px)` - 3 столбца с размером 50  
Вмесо количества повторений можно указать ключевые значения: 
	* `auto-fill` - заполняет свободное место пустыми колонками с равномерным распределением пространства между  
	пустыми и заполненные
	* `auto-fit` - схлопывает пустые колонки, оставляя больше место под заполненные  
[Как работает auto-fill auto-fit наглядное пособие](https://medium.com/@stasonmars/%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D1%8E%D1%82-auto-fill-%D0%B8-auto-fit-%D0%B2-css-grid-7d903a6c678e)  
* `grid-auto-columns, grid-auto-rows` - размер дополнительных линий при переполнении грид-сетки  
Приимают больше 1 значения (паттерн размеров), которые последовательно повторяются при переполнении грид-сетки  
* `grid-auto-flow` - тип дополнительных линий при переполнении
	* row(по умолчанию) 
	* column
	* dense (заполнение дырок в грид-сетке, если размеры добавляемых элементов позволяют)  
Пример:  
Грид-сетка (1 столбец, 3 ряда)  
При добавлении больше 3 элементов начнут создаваться колонки/ряды в зависимости от значения свойства `grid-auto-flow`  
с размерами в зависимости от `grid-auto-columns, grid-auto-rows`  
`grid-template` - шорткат для `grid-template-columns, grid-template-rows`. `Ряды / Колонки`  
`grid` - шорткат для всех свойств выше  
* `grid-template-areas` - шаблон расположения элементов внутри грид-сетки  
Имена областей задаются свойством `grid-area` у грид-элементов  
Пример шаблона:  
`.` - пустая ячейка  
```javascript
grid-template-area: 
	"header header header"
	"aside main ."
	"aside main ."
	"footer footer footer";
```
* `gap` - отступы между рядами и колонками. Шорткат для `row-gap, column-gap`
* `justify-content` - выравнивание элементов вдоль оси строки (start, end, center, stretch, space-around, space-between, space-evenly)
* `justify-items` - выравнивание внутри грид-элемента по горизонтальной оси (start, end, center, stretch)  
* `align=content` - выравнивание элементов вдоль оси ряда (start, end, center, stretch, space-around, space-between, space-evenly)
* `align-items` - выравнивание внутри грид-элемента по вертикальной оси (start, end, center, stretch)  
`place-items` - шорткат для `justify-items` и `align-items`  
`place-content` - шорткат для `justify-content` и `align=content`
* `justify-self, align-self` - изменение выравнивания отдельного элемента по горизонтальной/вертикальной  
`place-self` - шорткат для `justify-self, align-self`
* `grid-column, grid-row` - альтернативный способ позиционирования элемента внутри грид-сетки  
В качестве значений принимает номера грид-линий начала и конца грид-области `grid-row: line1 / 4;`  
Ключевое слово `span` указывает размер грид-области  
Пример: `grid-column: 3 / span 2`. Размер грид-области 2 грид-ячейки от 3 грид-линии до 5   
`grid-column` - шорткат для `grid-column-start, grid-column-end`  
`grid-row` - шорткат для `grid-row-start, grid-row-end`  

[Вернуться к содержанию](#содержание)

## 2.11 Директивы   

* `@import` - импортирование файла со стилями в другой файл со стилями или импорт шрифта (времязатратное подключение)
`@import 'style.css' print` - при импорте можно указывать медиа выражение
* `@media` - условные конструкции в стилях для разных параметров экрана  
Виды условий: 
	* тип устройства: all, print, screen
	* области разделения экрана (для складывающихся устройств): horizontal-viewport-segments/vertical-viewport-segments
	* поведение устройства с контентом непомествшимся на экран: overflow-block/overflow-inline  
	none (обрезается), scroll (скроллится), paged (разбит на страницы), optional-paged (комбинация scroll и paged)
	* разрешение в dpi: resolution, min-resolution, max-resolution
	* размеры страницы: width, min-width, max-width, height, min-height, max-height
	* ориентация окна браузера orientation (landscape, portrait) 
	* соотношение сторон: aspect-ratio, min-aspect-ratio, max-height
	* режим отображения: display-mode(browser - в браузере, fullscreen - в полноэкранном режиме,   
	minimal-ui - отдельная программа с минимумом элементов навигации, picture-in-picture - оконный режим поверх других программ,   
	standalone - нативная программа без элементов навигации)
	* поддерживаемый диапазон цветов: color-gamut
	* поддержка устройства ввода наводить указатель на элементы: any-hover(none, hover)
	* предпочитаемая пользователем тема: prefers-color-scheme(light, dark)  
Условия можно объединять (and), отрицать (not), выбирать из списка (запятая)  
В условиях с числовыми значениями можно использовать операторы сравнения: `680px <= width >= 1280px`
Медиавыражения поодерживают вложенность друг в друга  
_Перечислены только часто используемые условия_
* `@container` - условные контрукции в стилях для разных размеров контейнера 
		* размеры контейнера: width, height, inline-size, block-size
		* ориентация контейнера: orientation (landscape, portrait) 
		* соотношение сторон контейнера: aspect-ratio
Условия можно объединять (and), отрицать (not), выбирать из списка (запятая)  
* `@supports` - проверка поддерживаемости свойства - `@supports (display: grid) { }`  
В директиве доступны логические операторы and, or, not

[Вернуться к содержанию](#содержание)

## 2.12 Остальное

* `cursor` - вид курсора  
Можно указать в качестве курсора изображение (несколько изображений),  
тогда в качестве фолбека указывают системный вариант при ошибке загрузке изображения.  
Изображениям помжно задать смещение: `cursor: url('custom.png') -1 5, pointer`
* `user-select` - контроль выделения текста в элементе (none, text, all - в том числе для дочерних, contain - только в текущем элементе)
* `touch-action` - управление взаимодействием элемента с сенсорными экранами  
auto - разрешены все типы взаимодействия (по умолчанию), none, manupulation (только сдвиг и зум), pan-x, pan-y, pinch-zoom
* `pointer-events` - управление взаимодействием с указателем (мыши, тапа): none, auto
* `opacity` - прозрачность
* `visibility` - вилимость элемента (visible, hidden)
* `overflow` - поведение при переполнении элемента (hidden, scroll, visible, clip - аналогично hidden, но с учетом внутренних отступов, auto)  
Не применяется к строчным элементам
* `clip-path` - маска видимой области элемента  
inset() - прямоугольник, circle(), ellipse(), polygon() - многоугольник,   
path() - произвольный путь по правилам SVG, SVG-маски, блочная модель (margin-box и т.д.)
* `scroll-behavior` - управление поведением прокрутки внутри элемента (smooth - плавная, auto - мгновенная)  
Вляет **только** на прокрутку при переходе по якорным ссылкам
* `scroll-padding` - отступ от края контейнера прокрутки (по умолчанию якорный элемент прилипает к верху экрана)
* `scrollbar-color` - цвета thumb и полосы прокрутки (у свойства слабая поддержка, нужно использовать вендорные префиксы)
* `scrollbar-width` - толщина скроллбара (у свойства слабая поддержка, нужно использовать вендорные префиксы).  
Доступны только ключевые значения: auto, thin, none
* `scrollbar-gutter` - решает проблему сдвига контента при скрытии скроллбара под оверлеем модалального окна  
auto - для `overflow: scroll` (по умолчанию), stable - для `overflow: hidden`
* `apperance` - сброса системных стилей
* `resize` - переключение опции изменения размеров (используется для отмены опции у `<textarea>`): both, horizontal, vertical, none  
Не применяется к строчным элементам, блочным со свойством `overflow: visible`  
При использовании часто ограничивают изменяемые размеры min-width, max-width, min-height, max-height
* `zoom` - масштабирование элемента (в процентах, коэффицентах масштаба)  
Ключевое значение reset - не применяет масштабирование для увеличения не на сенсорном устройстве
* `color-scheme` - выбор предпочтительной цветовой схемы (dark light)  
Первое значени указывает предпочтительную тему. Ключевое слово only указывает работу только в одной цветовой схеме  
Лучше указывать в meta информации, так как браузер обрабатывает ее быстрее загрузки стилей  
* `caret-color` - цвет курсора кареткки
* `float` - направление обтекания строчными элементами блока (left, right, none)
* `windows` - минимальное количество строк на новой странице (для @media print)
* `orphans` - минимальное количество строк в нижней части текущей страницы (для @media print)  
[Примеры orphans, windows](https://basicweb.ru/css/css_pr_widows.php)
* `caption-side` - положение `<caption>` внутри `<table>` (top, bottom)
* `accent-color` - цвет контролов (чекбоксов, радиокнопок и т.д.)  
* `attr()` - функция для получения значения атрибута (используется в свойстве `content`)
* `url()` - вставка ссылки

---
  
### Кастомные свойства  
  
* `var()` - вызов кастомного свойства  
Можно задать фолбек `var(--accent-color, grey)`  
Браузер последовательно ищет кастомное свойство в родительских элементах вплоть до `:root`.  
Если свойство не найдено или невалидное, то установится значение initial для ненаследуемых свойств    
Пример (кастомное свойство найдено в родителе, фолбек игнорируется,   
свойство невалидное, установится initial, который сброисит браузерный стиль до inline)
```javascript
<section>
  <div>
    текст
  </div>
</section>

section {
  --display: grey
}
div {
  display: var(--display, flex)
}
```

### Счетчики CSS

* `counter-reset` - создание счетчика: `conter-reset: timerName 0`
Поддерживает создание нескольких счетчиков
* `counter-increment` - увеличение счетчика на заданную величину: `conter-increment: timerName 2`  
Если указан несуществующий счетчик, то работает как `counter-reset`
* `counter-set` - изменение текущего значения счетчика на указанную: `conter-set: timerName 10`  
Если указан несуществующий счетчик, то работает как `counter-reset`
Функции `counter(), counters()` отображают значение счетчика. Используется в свойстве `content`  
`counters()` - указывает разделитель между вложенными счетчиками  
```javascript
ul { counter-reset: example 0; }  
li { counter-increment: example 2; }
```
Порядок вычисления счетчиков:  
1. Наследование счетчиков - элемент наследует начальный набор счетчиков от родителя и предыдущего одноуровневого элемента  
2. Наследование значений - значения счетчиков наследуются от предыдущего элемента в порядке дерева  
(родитель, одноуровневый элемент, дочерний элемент предыдущего одноуровневого элемента)  
3. Создается новый счетчик при наличии `counter-reset`
4. Значение последнего счетчика увеличивается на `counter-increment`
5. Устанавливается точное значение из `counter-set`

[Вернуться к содержанию](#содержание)