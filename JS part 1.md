# JavaScript Guide

# Содержание
* [1. Переменные](#1-переменные)  
* [2. Условия](#2-условия)  
* [3. Циклы](#3-циклы)  
* [4. Типы](#4-типы)  
	- [4.1 Строки (String)](#41-строки-string)  
	- [4.2 Числа (Number, BigInt)](#42-числа-number-bigint)
	- [4.3 Boolean, Undefined, Null](#43-boolean-undefined-null)
	- [4.4 Symbol](#44-symbol)
	- [4.5 Приведение типов](#45-приведение-типов)
* [5. Функции](#5-функции)  
	- [5.1 Контекст функции](#51-контекст-функции)  
	- [5.2 Closures (Замыкания)](#52-closures-замыкания)  
	- [5.3 Каррирование](#53-каррирование)  
* [6. Массивы](#6-массивы)  
	- [6.1 Типизированные массивы](#61-типизированные-массивы)  
* [7. Объекты](#7-объекты)  
	- [7.1 Поверхностное и глубокое копирование](#71-поверхностное-и-глубокое-копирование) 
	- [7.2 Дескрипторы свойств](#72-дескрипторы-свойств) 
	- [7.3 Прототип объекта](#73-прототип-объекта) 
	- [7.4 Опциональная цепочка](#74-опциональная-цепочка) 
* [8. Итераторы и генераторы](#8-итераторы-и-генераторы)  
	- [8.1 Итератор](#81-итератор) 
	- [8.2 Генератор](#82-генератор) 
* [9. Spread синтаксис и деструктуризация](#9-spread-синтаксис-и-деструктуризация)  
	- [9.1 Spread](#91-spread) 
	- [9.2 Rest](#92-rest) 
	- [9.3 Деструктуризация](#93-деструктуризация) 
* [10. Map, Set](#10-map-set)  
	- [10.1 Map](#101-map) 
	- [10.2 Set](#102-set) 
	- [10.3 WeakMap](#103-weakmap) 
	- [10.4 WeakSet](#104-weakset) 
* [11. Асинхронность](#11-асинхронность)  
	- [11.1 Promise](#111-promise) 
	- [11.2 Async, await](#112-async-await) 
	- [11.3 fetch](#113-fetch) 
	- [11.4 Таймеры](#114-таймеры) 
	- [11.5 Observer'ы](#115-observerы) 
	- [11.6 queueMicrotask, requestAnimationFrame, requestIdleCallback](#116-queuemicrotask-requestanimationframe-requestidlecallback) 
* [12. Error Handling](#12-error-handling)  
* [13. Event Loop](#13-event-loop)  
	- [13.1 Очередность](#131-очередность) 
* [14. Модульность](#14-модульность)  
* [15. Web-worker](#15-web-worker)  
* [16. Работа с памятью](#16-работа-с-памятью)  
	- [16.1 cookie](#161-cookie) 
	- [16.2 Web Storage](#162-web-storage) 
	- [16.3 IndexedDB](#163-indexeddb) 
* [17. throttle и debounce](#17-throttle-и-debounce)  
* [18. Дополнительно](#18-дополнительно)  

## 1. Переменные

В названии переменных используются латинские буквы, цифры (не в начале переменной), символы($, _)  
Типы переменных:
|    | var | let | const |
|----|-----|-----|-------|
|Объявление без присваивания|Можно|Можно|Нельзя|
|Повторная инициализация|Можно|Нельзя|Нельзя|
|Всплытие|Есть|Нет|Нет|
|Область видимости|Функциональная|Блочная|Блочная|
|Изменение значения|Можно|Можно|Только мутирование|

**Объявление**  
```javascript
const variable // ошибка
let variable1 // undefined
var variable2 // undefined
```
**Повторная инициализация в той же области видимости**
```javascript
var a = 5   
var a = 6
```
**Всплытие(hoisting) - обращение до объявления**
```javascript
console.log(a) // undefined
var a = 5
```  
Но `let, const` можно использовать до объявления, если условие содержащее переменные будет выполнено после инициализации переменных  
```javascript
function func() { console.log(a) }
Promise.resolve().then(() => console.log(a))
setTimeout(() => console.log(a)) 
const a = 1;
func()
```

>При создании переменной без `var, let, const` - она будет создана в глобальной области видимости, даже если объявлена внутри функции  
`function myFunction () { a = 10 }`

[Вернуться к содержанию](#содержание)

## 2. Условия

Условие `if(variable) {}`  неявно преобразует `variable` в Boolean  
Тернарная запись условия `if`, возвращающая значение `const variable = condition ? truthValue : falseValue` 

**Нестандартное использование логических операторов:**   
1. `<условие> && <выражение>` аналог `if (<условие>) {<выражение>}`  
В сокращенной записи логическое И **не преобразует типы** в Boolean.  
Если левую часть можно привести к true возвращает правую. Если левая часть приводится к false возвращает левую:  
```javascript
console.log(null && 0) // null 
console.log('Собака' && 'Кошка') // Кошка
```  
2. Логическое ИЛИ в сокращенной записи позволяет установить значение переменной по умолчанию  
Cокращенная запись: `const value = externalValue || 0`  
В сокращенной записи логическое ИЛИ **не преобразует типы** в Boolean.  
Если левую часть можно привести к false возвращает правую. Если левая часть приводится к true возвращает левую
```javascript
console.log(null || 0) // 0
console.log('Собака' || 'Кошка') // Собака
```
Аналог:   
```javascript
let value = 0 // значение по умолчанию
if (externalValue) {value = externalValue} 
```
3. Нулевое слияние (nullish coalescing) - проверка переменной на null и undefined  
Cокращенная запись: `const value = externalValue ?? 42`  
Оператор `??` устанавливает первый операнд, если он не `null` и не `undefined`.  
Аналог: `const value = (externalValue !== null && externalValue !== undefined) ? externalValue : 42 ` 

---  

В условном операторе `switch` в `case` также можно использовать `{}` для ограничения области видимости переменных  
Рекомендуется всегда указывать `default` для исключения возможных ошибок при расширении кода    
```javascript
switch(condition) {
	case 1: { const variable = 5; break; }
	default: return null;
}
```

[Вернуться к содержанию](#содержание)

## 3. Циклы 

`continue label` и `break label` позволяют продолжить/прекратить итерацию конкретного элемента на любом вышестоящем уровне вложенности  
```javascript
labelName: for() {
	for() {break labename}
}
```

* `for..of` - цикл обхода перечисляемых свойств итерируемой сущности  
К итерируемым сущностям относятнся: _массив, строка, NodeList, HTMLCollection, Map, Set, генератор, arguments функции и т.д._    
Обход осуществляется по значениям элементов  
Для одновременного доступа к паре ключ-значение используется деструктуризация:  
 `for (let [key, value] of array) {}`  
 
```javascript
const array = ['a', 'b', 'c']
array.name = 'Petr'
for (const value of array) {
	// обход осуществляется по элементам, name является дополнительным свойством
  console.log(value); // a b c
}
```
* `for..in` - цикл обхода по ключам перечисляемых свойств объекта, в том числе по свойствам прототипов объекта.  
_Исключения из перечисления:_ Symbol, поля с флагом iterable = false, встроенные свойства (length, toString и т.д.)  
При одинаковых свойствах в цепочке прототипов учитывается только первое из них  
Порядок перечисления в объекте не регламентирован. Один из частых вариантов: числовые значения в порядке возрастания, строковые в порядке присвоения объекту  
Не рекомендуется применять к массивам, т.к. переменная цикла будет иметь тип `string` и в перечисление попадут наследуемые и строковые свойства  

[Вернуться к содержанию](#содержание)

## 4. Типы 
 
* Примитивные (`string, number, bigint, boolean, null, undefined, symbol`) - в переменную записывается значение 
* Ссылочные (`object`)  - в переменную записывается ссылка на "объект" в памяти  

Примитивные типы (за исключением `null, undefined`) при вызове методов оборачиваются (autoboxing) в соответствующие объекты-обертки (`String, Number и т.д.`)  

`let ob1 = {}; let obj2 = obj1;` - оба объекта ссылаются на одну и ту же область в памяти.  
Изменение данных в `obj2` ведет к изменению в `obj1` - **мутация**  

[Вернуться к содержанию](#содержание)

### 4.1 Строки (String)

При **сравнение строк** - сравниваются символы с учетом регистра по нумерации в кодировке  

**Работа со строками:**  
* `str.at(index)` - возвращает символ строки по указанному индексу (отрицательный индекс начинает отсчет с конца строки)
* `str.startsWith(searchString[, position])` - возвращает boolean. Начинается ли строка с указанных символов, начиная с начала(или с заданной позиции)
* `string.endWith(searchString[, position])` - возвращает boolean. Заканчивается ли строка на указанные символы (обрезая по указанному диапазону)
* `str.includes(searchString[, position])` - возвращает boolean. Cодержит ли строка заданную подстроку, начиная с начала (или с заданной позиции)
* `str.indexOf(searchValue, [fromIndex])` - возвращает индекс первого вхождения указанного значения, начиная от начала к концу (с индекса fromIndex). -1, если не найдено
* `str.search([regexp])` - аналогично indexOf с возможностью передать regExp
* `str.lastIndexOf(searchValue[, fromIndex])` - возвращает индекс последнего вхождения указанного значения, начиная с конца (с индекса fromIndex). -1, если не найдено
* `str.substring(indexA[, indexB])` - извлекает часть строки от первого индекса до конца (или *строго до* (<) последнего индекса)
* `str.slice(beginIndex[, endIndex])` - аналогично substring, с возможностью указывать отрицательные индексы  
* `str.match(regexp)` - возвращает совпадение с regExp
* `str.matchAll(regexp)` - возвращает итератор по всем паттернам совпадения с regexp
```javascript
const regexp = /t(e)(st(\d?))/g;
const str = 'test1test2';
const arrayMatch = str.match(regexp);
const arrayMatchAll = [...str.matchAll(regexp)];
console.log(arrayMatch); // Array ["test1", "test2"]
console.log(arrayMatchAll[0]); // Array ["test1", "e", "st1", "1"]
console.log(arrayMatchAll[1]); // Array ["test2", "e", "st2", "2"]
```
* `str.split([separator[, limit]])` - разбивает строку на массив по разделителю (с не большим указанного количества совпадений)  
*	`str.toLowerCase()`, `str.toUpperCase()` - перевод строки в нижний/верхний регистр
* `str.trimStart()`, `str.trimEnd()`, `str.trim()` - удаляет пробельные символы (в том числе табуляция, nbsp и т.д.) с начала/конца/с обеих сторон строки
* `str.padStart(targetLength [, padString])`, `str.padEnd(targetLength [, padString])` - дополняет строку с начала/конца с помощью заданной до укананной длины
* `str.repeat(count)` - повторяет строку указанное количество раз
* `str.replace(regexp|substr, newSubStr|function[, regexpFlags])` - возвращает новую строку с заменой первого совпадения из первого параметра на второй. Примеры передачи строки в [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/replace)
* `str.replaceAll(regexp|substr, newSubstr|function)` - возвращает новую строку с заменой всех совпадений из первого параметра на второе

В пользовательском вводе могут использоваться emoji, так как они входят в состав кодировки, длина которых не равна одному символу.  
Правильный способ определения длины строки: `str.split('').length`,  `[...str].length`  

**Задача на поворот (reverse) строки:**  
[Устройство Emoji в юникоде (малополезно) ](https://habr.com/ru/companies/itelma/articles/549366/) 
```javaScript
const str = 'hello 😀 ☹️ 👦🏿 👨🏻‍🏫 🇬 1️⃣  👩‍🦰👩‍👩‍👦‍👦
```
Различные варианты emoji: 
- одиночный codepoint 
- одиночный codepoint + variation selector-16
- модификатор оттенка кожи
- последовательность с zero-width joiner
- флаг
- keycap
- тройной emoji

* `str.split('').reverse().join('')` - переворачивает символы внутри составных emoji, чем нарушает их целостность  
* `[...str].reverse().join('')` - чуть лучше первого варианта. Правильно работает только с одиночными codepoint  
* `'\u202e' + str` - символ поворота строки работает правильно с любыми emoji   
* метод `_split` библиотеки `lodash` решает проблему поворота строки с emoji

**Задача - сделать аналог IndexOf**:
1. Поиск скользящим окном от *pos* до *string.length-substr.length* на совпадение substring/slice. Сложность алгоритма: O(длина строки * длина подстроки)
2. Алгоритм Бойера — Мура. Создаем массив поиска для подстроки, состоящий из charCodeAt(Юникод). Проверяем с конца совпадения с подстрокой.  
[Вики: Алгоритм Бойера — Мура](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%91%D0%BE%D0%B9%D0%B5%D1%80%D0%B0_%E2%80%94_%D0%9C%D1%83%D1%80%D0%B0)  
[Наглядный пример: Алгоритм Бойера-Мура](https://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%91%D0%BE%D0%B9%D0%B5%D1%80%D0%B0-%D0%9C%D1%83%D1%80%D0%B0)  
```javascript
Строка:_______* * * * * * к * * * * * *  
Шаблон:_______к о л о к о л  
Следующий шаг:____к о л о к о л  
```
Если нет совпадения("л" != "к"), алгоритм ищет вхождение символа(charCodeAt) строки ("к") в подстроке и происходит сдвиг на количество позиций равных индексу символа в подстроке (у "к" 2 позиция) (отсчет с 0 справа).  
```javascript
Строка:_______* * * * * а л * * * * * * * *  
Шаблон:___________п о с о л  
Следующий шаг:______________п о с о л  
```
Если найдено некторое количество совпадений ("л" == "л") и до конца подстроки произошло расхождение ("а" != "о"), то сдвиг производится на позицию ближайшего совпадения ("л"), перед которым нет несовпавшего символа ("о"). Если в подстроке не найдено новых совпадений, то сдвиг производится на длину подстроки.   
Еще пример предыдущего случая:  
```javascript
Строка:_______* * * * * * р к а * * * * *  
Шаблон:_______с к а л к а л к а` `// не совпал "р" != "л"   
Следующий шаг:____________с к а л к а л к а // в подстроке совпадение "к а" без "л" перед ней - "с к а"  
```
Однако если результат совпадения длиннее 1 символа и в подстроке не найдено полное вхождение, то начинается поиск усеченного совпадения:  
```javascript
Строка:________* * т о к о л * * * * * 
Шаблон:________к о л о к о л
Следующий шаг:_________к о л о к о л
```
Результат `"о к о л"` без `"л"` впереди не найден. Начинается поиск `"к о л"` без `"л о"` впереди.  
Сложность алгоритма О(длина строки / длина подстроки). В худшем случае(длина строки * длина подстроки)  

**Теговый шаблон** - специальная функция разбивающая шаблонную строку на массив из кусочков строк между которыми стояли выражения в `${}` и значения выражений в качестве остальных параметров.  
Вызов без круглых скобок: `templateFunc`\``Пример ${value1} текста ${value2}`\`  
Функция выведет: `['Пример ', 'текста ', ''], value1, value2`  

[Вернуться к содержанию](#содержание)

### 4.2 Числа (Number, BigInt)

К типу `Number` также относятся `NaN`, `Infinity`, `-Infinity`  
Числа могут быть записывать с разделителем (`1_000_000`), в экспоненциальноф форме (`1e6`), в других системах счисления (`0b11`, `0o77`, `0xFF`)  

Работа с числами:  
[Math](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math)  
* `Math.floor` - округление вниз  
* `Math.ceil` - округление вверх  
* `Math.round` - стандартное округление  
* `Math.trunc` - отбрасывание дробной части  
* `Math.random` - псевдослучайная генерация чисел от 0 строго ДО 1 (< 1). **Не используется в криптографии**  
`window.crypto.getRandomValues(typedArray)` - один из вариантов генерации случайных чисел для криптографии, где  
`typedArray` - типизированные массивы см. ниже (`Int8Array`, `Uint8Array`, `Uint8ClampedArray`, `Int16Array`, `Uint16Array`, `Int32Array`, `Uint32Array`, `BigInt64Array`, `BigUint64Array`). `Float` **использовать нельзя**  
>`Math.random() * (max - min) + min` - генерация числа в диапазоне min, max  

>`-~n` - альтернативный инкремент числа, где побитовый сдвиг числа `n` возвращает `-n - 1`.  
В отличие от обычного инкремента `++`, можно работать с `undefined`. `-~undefined === 1`

* `Number.isFinite(value)` - определяет, является ли `value` конечным числом, а не специальным значением(Infinity, NaN). Преобразование типа не осуществляется  
* `Number.isNaN(value)` - определяет является ли `value` NaN. Преобразования типа не осуществляется  
>Альтернативный способ проверки: `Object.is(value, NaN)`, т.к. `NaN` строго не равен `NaN`, но имеет одно и то же значение  
```javascript
Object.is(NaN, NaN); // -> true
Object.is(NaN, 0 / 0); // -> true
NaN === NaN; // -> false
NaN === 0 / 0; // -> false

Object.is(-0, 0); // -> false
-0 === 0; // -> true
```

>`NaN === NaN // false`, т.к. условия проверки `x === y`:  
>1. если тип `x` и `y` отличаются, вернуть `false`
>2. если `typeof x === 'number'`, то если `x` это `NaN` вернуть `false`
>3. если `y` это `NaN` вернуть `false`
	
* `Number.isInteger(value)` - определяет, является ли `value` целым числом. Преобразования типа не осуществляется  
* `Number.parseInt(string[, radix])` - возвращает целое число в заданной системе счисления `radix`    
Возвращает число в случае, если первый символ удалось преобразовать в число (не считая пробелов), иначе NaN. Останавливается на первом не числовом символе  
Если символ (первый аргумент) имеется в разрядной сетке числовой системы (второй аргумент), то вернется число `parseInt("f*ck", 16); // -> 15`
* `Number.parseFloat(string)` -  возвращает число с плавающей точкой  
Возвращает число в случае, если первый символ удалось преобразовать в число (не считая пробелов), иначе NaN. Останавливается на первом не числовом символе или второй точке (.)  
`+str`, `Number(str)` - приведение к числовому типу  
>**НО** `Number('4a')` - NaN, `+'4a'` - NaN, `parseInt('4a')` - 4, `Number.parseInt('4a')` - 4  
По умолчанию аргументом `Number` является `0`, а не `undefined`, поэтому `Number(); // -> 0`, `Number(undefined); // -> NaN`
* `numObj.toFixed([digits])` - возвращает **строку** с заданной точностью `digits` (без параметра - отбрасывает дробную часть без округления, с параметром - округляет)  
* `numObj.toPrecision([precision])` - возвращает **строку** с заданной точностью `precision`  
**Отличие toFixed от toPrecision**: в `toFixed` передается число знаков после запятой, а *toPrecision* - общее число знаков  
```javascript
const variable = 12.3456 
variable.toFixed(2) // 12.35
variable.toPrecision(2) // 12
```
* `numObj.toString([radix])` - преобразует `numObj` в строку в заданной системе счисления `radix` (по умолчанию десятичная)  

---

### BigInt  

Способы создания: `123n` иди `BigInt(123)`  
Используется для больших чисел и чисел высокой точности (2^53 - 1)  
В операциях деления **отбрасывается дробная часть!**  
>Нельзя оперировать одновременно с `BigInt` и `Nubmer` - нужно явное приведение типов  
`let a = 10, b = 10n // a !== b`  

>`BigInt` **НЕ сериализуется в формат JSON**. Нужно перевести его в строку, а затем при парсинге обратно в `BigInt()`  

[Вернуться к содержанию](#содержание)

### 4.3 Boolean, Undefined, Null  

Двойное отрицание `!!` - упрощенное преобразование к логическому типу. `!!variable`   
**Undefined** - используется для обозначения переменной, которой не присвоено значение, где переменная не объект
* значение по умолчанию для инициализированных переменных, которым не присвоено начальное значение
* возвращаемое значение из функций без return (void)  
* значение по умолчанию для не переданных аргументов функции
* результат обращения к несуществующему свойству объекта
* и т.д.  

**Null** - используется для обозначения объекта с неопределенной структурой, намеренного отсутствия значения переменной 

[Вернуться к содержанию](#содержание)

### 4.4 Symbol

Примитивный тип данных, создается через функцию `Symbol([description])`.  
Символ создает скрытые свойства в объекте, которые не выводятся через `Object.keys(obj)`, `for..in`, но к ним можно обратиться по имени:      
```javascript
let id = Symbol('id') 
const obj = {[id]: 'dog' }  // свойство-символ внутри объекта обязательно записывается через []
obj[id] // доступ к символу  
```
Метод `for` создает символ в глобальном реестре. В глобальном реестре могут быть только **уникальные** символы  
```javascript
Symbol.for(key) // чтение/создание символа в глобальном реестре. 
Symbol.keyFor(sym) // возвращает имя символа из глобального реестра 
```

```javascript
// разные символы
let differentSymbol1 = Symbol('mouse'), differentSymbol2 = Symbol('mouse')
console.log(differentSymbol1 === differentSymbol2) // false 
// одинаковые символы
let sameSymbol1 = Symbol.for('cat'), sameSymbol2 = Symbol.for('cat') 
console.log(sameSymbol1 === sameSymbol2) // true 
```

[Well-known symbols](https://h3manth.com/posts/Well-known-symbols/)  
**Задача: использовать "стратегию" для расширения split** (Дока)  
Стратегия - расширение базового класса за счет передачи в него _конкретного_ класса.  
```javascript
class MyClass {
	constructor(value){ 
		this.value = value  
	} 
}	
[Symbol.split](string) {...реализация функции}
str.split(new MyClass(arg))   
```

[Вернуться к содержанию](#содержание)

### 4.5 Приведение типов

* `typeof NaN === 'number'`   
* `typeof Infinity = 'number'`
* `typeof [] === 'object'`
* `typeof function(){} === 'function'`
* `typeof null === 'object'` **!**

**Строковое преобразование** неявное: унарный плюс, если один из аргументов строка
* `[]` - `''`  
* `[1, 2]` - `'1,2'`  
* `{}` - `'[object Object]'`  
* остальные преобразуются как записаны, например `123` - `'123'`, null - 'null'

**Числовое преобразование** неявное: `*, /, -, (унарный плюс), <, >, <=, >=, ==, +(если оба аргумента не строки)`
* `true` - 1  
* `false` - 0  
* `null` - 0  
* `undefined` - NaN  
строки преобразуются в числа, если содержат 0-9 и один знак точки (.), не учитывая `\n \t` и знаки пробелов по краям, иначе NaN  
* `''` - 0  
* `function(){}` - NaN  
* `{}` - NaN  
* `[]` - 0  
* `[1]` - '1'  
* `[1, 2]` - NaN

**Логическое преобразование** неявное: `&&, ||`
* `0, 0n, -0, null, undefined, ``, Nan` - false  
* `остальные` - true  
Нестрогое равенство `==` отличается от строгого `===` тем, что нестрогое равенство неявно преобразует типы; строгое сначала сравнивает типы, потом значения без приведения типов  

[таблица строгого равенство](https://doka.guide/js/typecasting/images/2-1200w.webp)  
[таблица нестрогого равенство](https://doka.guide/js/typecasting/images/1-1200w.webp)  
[странности неявных преобразований](https://github.com/denysdovhan/wtfjs)  

>null **строго равен ТОЛЬКО undefined и самому себе.**   
Аналогично для undefined: `null == undefined // true`  
Поэтому `null == 0 // false`, `undefined == 0 // false`  
другие типы сравнений валидны: `null >= 0; // -> true`

### Примеры преобразований типов  

1. Числовое преобразование: `[] => 0` и Логическое преобразование `![] => false`  
```javascript
[] == ![]; // -> true
 
true == []; // -> false
true == ![]; // -> false

false == []; // -> true
false == ![]; // -> true

!![] // -> true
```

2. Логическое преобразование непустой строки => true  
```javascript
!!"false" == !!"true"; // -> true
!!"false" === !!"true"; // -> true
```

3. baNaNa  
Преобразование строки в число с помощью унарного оператора `+'Text' => NaN`, если в строке содержатся символы отличные от `[0-9]` и знака `.` для дробной части  
```javascript
"b" + "a" + +"a" + "a"; // -> 'baNaNa'

"foo" + +"bar"; // -> 'fooNaN'
```

4. Сложение массивов  
Приведение массива к строке `[1, 2, 3].toString() => '1, 2, 3'`
`[1, 2, 3] + [4, 5, 6] // -> '1,2,34,5,6'`

5. Преобразования массивов  
При преобразовании массива к примитиву `[0].toString() => '0'`, где строка приводится к числу или сравнивается с пустой строкой
```javascript
[0] == 0   // -> true
[0] == ''  // -> false // !!!
```

6. Сложение массива с объектом  
В первой строке `{}` считается пустым блоком кода и унарный плюс приводит массив к числу  
Во второй строке оба слагаемых приводятся к строке  
```javascript
{} + [] // -> 0
[] + {} // -> '[object Object]'
```

[Вернуться к содержанию](#содержание)

## 5. Функции 

Функция является **объектом первого класса (First-class Object)**, т.к. это объект, который можно передать как аргумент функции, вернуть из функции и присвоить переменной.  
**HOF (Highter Order Function)** - функция, принимающая в качестве аргументу другие функции и/или возвращает в результате своей работы функцию  
Способы создания: 
* function declaration (стандартная функция) 
```javascript
function func(args) {...код}
```
* function expression (анонимная, стрелочная), явдяется выражением, поэтому должна быть присвоена переменной  
	* Анонимная функция - используется, когда функцию не собираются использовать многократно
	* Стрелочная функция - упрощенная запись анонимной функции
```javascript
const anonymousFunction = function() {...код}
const arrowFunction = () => ...код
```
Вариативность записи стрелочной функции:  
* если тело функции простое, например `a ** 2`, то оператор `return` не обязателен (неявный return (implicit)). `() => a ** 2`
* если тело функции сложное, то требуются `{}`: `() =>` **{**`let a = 3;` **return** `a ** 2`**}** 
* если нужно вернуть объект, то `() =>` **(**`{objElement: value}`**)**  
* если 1 аргумент можно обойтись без скобок `()`: `arg => {}` 
* если > 1 аргумента `(arg1, arg2 = null) => {}`. Пример с указанием значения по умолчания 2му аргументу  

Типичные случаи использования анонимных функций:  
* IIFE
* callback-функции
* работа с методами массивов
* обработчики событий (eventListener)  
* асинхронные операции  
* замыкания  

**Всплытие(hoisting)** - вызов функции до объявления. Доступно в Function Declaration, но не в Function Expression   
```javascript
func() // вызов до определения  
function func(){}
```  

**IIFE(Immediately Invoked Function Expression)** - функция выполняемая сразу после определения:  
1 - круглые скобки вокруг определения функции
2 - круглые скобки после определения (вызов функции)
```javascript
(function(){...код})() 
``` 
IIFE ограничивает доступ к переменным внутри себя, защищая код от ошибок перезаписи переменных с одинаковыми именами, уменьшает количество переменных в глобальной области видимости  

**Callback функции** - функции переданные в качестве аргументов в другую функцию  
```javascript
function func(arg1, arg2)
function func1(){}  
function func2(){}  
func(func1, func2) 
```

**Рекурсия** - вызов функции внутри самой себя, но это должно быть оправдано, так как сложность алгоритма рекурсии самое времязатратное  
Любая рекурсия содержит _базовый случай_ для прекращения самой рекурсии. Для уменьшения ресурсозатрат можно мемоизировать рекурсивные значения  

Мемоизация на примере функции Хофстедера: `Q(1) = Q(2) = 1; Q(n) = Q(n - Q(n - 1)) + Q(n - Q(n - 2))`  
Использовано каррирование (разделение передаваемых аргументов) и IIFE для передачи значений первых двух элементов
```javascript
const hofstadterQ = (cache => n => {
   if (cache[n] === undefined) {
      cache[n] = hofstadterQ(n - hofstadterQ(n-1)) + hofstadterQ(n - hofstadterQ(n-2));
   }
   return cache[n];
})({1: 1, 2: 1});
```
Рекурсия может быть переписана через цикл, скорость выполнения увеличится, но код может стать менее читаемым  
```javascript
const hofstadterQ = n => {
	const res = [1, 1];
	while (res.length < n) {
		const prevIndex1 = res.length - res[res.length - 1], 
          prevIndex2 = res.length - res[res.length - 2];		
		res.push(res[prevIndex1] + res[prevIndex2]);
	}

	return res[res.length - 1];
}
```

[Вернуться к содержанию](#содержание)

### 5.1 Контекст функции  

Контекст обычной функции определяется в момент вызова:  
* если функция вызывается как метод объекта `obj.method()`, то `this` ссылается на объект obj
* если функция вызывается стандартно `myfunc()`, то `this` ссылается на глобальный объект
* если функция вызывается с использованием `call, bind, apply`, то `this` - ссылается на переданный объект  

**Отличие стрелочной функции**    
* Стрелочные функции не имеют свойств `constructor`, `protorype` - значит нельзя использовать с оператором `new`  
* Стрелочные функции нельзя использовать как генераторы, т.к. `super` ссылается на внешнее окружение, а не на родительский класс   
* Стрелочные функции не имеют собственного контекста (this) и ссылаются на контекст внешней функции, если ее нет, то на глобальный контекст (window в браузере)  

>При любом количестве вложенных друг в друга стрелочных функциях они будут ссылаться на контекст самого верхнего уровня.  
Если функция самого верхнего уровня - стрелочная, то все ссылаются на глобальный контекст, если анонимная/обычная, то на их контекст.  
`this` вложенных обычных/анонимных функций **не привязан** к родительскому объекту (можно явно задать контекст через `bind`)  

**Пример 1**  
```javascript
const obj = { 
  name: 'Petr',
	// обычные функции-методы привязывают this к самому объекту
	regularFunction: function regularFunction() { return this.name }, // Petr
	// поведение анонимных функций аналогично обычным  
	anonymousFunction: function() { return this.name }, // Petr
	// стрелочные функции не имеют своего this и захватывают контекст из окружающей области видимости (в данном случае глобальный контекст - window)   
	arrowFunction: () => { return this.name },
	// пример для анонимной и обычной функций  
	// this внешней функции ссылается на объект. this вложенной функции уже не будет привязан к объекту и будет зависеть от контекста вызова или окружающей области (в данном случае глобальный контекст - window)  
	outerFunction: function() { 
		const nestedFunction = function() { return this.name }  
		return nestedFunction()
	},
	// стрелочная функция захватывает контекст из внешней функции, которая ссылается на родительский объект  
	outerFunctionWithNestedArrow: function() {  
		const nestedArrowFunction = () => { return this.name } 
		return nestedArrowFunction()  // Petr
	}
} 
console.log(obj.regularFunction())
```
**Пример 2**

```javascript
function foo() {
	const x = 10;
	return {
		x: 20,
		bar: function () { console.log(this.x) },
		baz: () => { console.log(this.x) }
	}
}

const obj = foo();
obj.bar() // функция вызвана как метода объекта и имеет его контекст. Результат 20
obj.baz() // стрелочная функция берет контекст внешней функции foo. Контекст функции foo - глобальный. Результат undefined

const obj2 = foo.call({ x: 30 })
let y = obj2.bar;
let z = obj2.baz;
y() // функция вызвана не как метод объекта, контекст стал глобальным. Результат undefined
z() // через call был передан контекст. Результат 30

obj2.bar() // функция вызвана как метод объекта и имеет его контекст. Результат 20
obj2.baz() // через call был передан контекст. Результат 30
```

**Пример 3**
```javascript
function independentFunction () {
  return this.name
}
const obj = {
  name: 'Petr',
  method() {
		// контекст функции определяется при вызове. this ссылается на глобальный контекст
    return independentFunction();
  }
}
console.log(obj.method())
```

**Конструктор** - функция, используемая для создания однотипных объектов  
При вызове "под капотом" создается пустой объект и ему присваивается `this`, выполняется код функции, возвращается this   
[То же самое в видео-формате](https://www.youtube.com/watch?v=BrWzZPmJvEs)  
```javascript
function User(name) {
	this.name = name
}
const petr = new User('Petr')
User.prototype = { age: 18 } // присваивание прототипа всем объектам создаваемым через `new User`
```
Функция-конструктор **должна** вызываеться с помощью `new`.  
`new.target` позволяет определить была ли функция конструктор вызвана с помощью `new`  
```Javascript
function Animal(name) {
	if (!new.target) {
    return new Animal(name)
  }
	this.name = name
}
```

Если использовать в функции-конструкторе оператор `return`, то если возвращаемое значение объект - вернется объект, иначе `this`  
[Преимущество использования стрелочных функций в конструкторе](https://www.greatfrontend.com/questions/quiz/what-advantage-is-there-for-using-the-arrow-syntax-for-a-method-in-a-constructor)  

**Методы работы с контекстом:**  
* `func.call(<context>[, arg1[, arg2[, ...]]])` - вызывает функцию с переданным контекстом и аргументами  
* `func.apply(<context>, [argsArray])` - аналогично `call`, но аргументы передаются в виде массива    
* `func.bind(<context>[, arg1[, arg2[, ...]]])` - возвращает новую функцию и привязывает к ней переданный контекст без вызова самой функции (контекст у функции больше изменить нельзя)  
Пример передачи в `bind` аргументов по умолчанию:  
```javascript
function myFunc(arg1, arg2){}
// последующий вызов функции будет происходить с дефолтным arg1
const newFunc = myFunc.bind(context, arg1)   
newFunc(arg2)
```
Для использования с анонимной функцией ее нужно обернуть в круглые скобки: `(function(){}).call()`  
Варианты использования методов: сохранение контекста во вложенной обычной или анонимной функции; одалживание методов одного класса/объекта в другой (пример ниже):  
```javascript
function donor(name){ this.name = name } 
// вызываем функцию-конструктор Donor внутри Aceptor с собственным контекстом  
function aceptor(name){ donor.call(this, name) } 
```
>`call, bind, apply` - не изменяют контекст стрелочной функции  
```javascript
const Person = function (firstName) {
	this.firstName = firstName;  
	this.sayName1 = function () { console.log(this.firstName); }
	this.sayName2 = () => { console.log(this.firstName); }
}  
const john = new Person('John');
const dave = new Person('Dave');

john.sayName1.call(dave); // Dave  
john.sayName2.call(dave); // John 

john.sayName1.apply(dave); // Dave  
john.sayName2.apply(dave); // John  

john.sayName1.bind(dave)(); // Dave  
john.sayName2.bind(dave)(); // John  

// теперь this - глобальный, так как контекст указывается слева от точки  
var sayNameFromWindow1 = john.sayName1; 
sayNameFromWindow1(); // undefined  

var sayNameFromWindow2 = john.sayName2;  
sayNameFromWindow2(); // John
```
[Если хочется посмотреть видео по методам работы с контекстом](https://www.youtube.com/watch?v=mbXeV_VnaJQ)  
[Еще одно видео](https://www.youtube.com/watch?v=CJ6Txj8leZQ)  

[Вернуться к содержанию](#содержание)

### 5.2 Closures (Замыкания)  

Это способность функции запоминать переменные, которые были определены внутри родительской функции, даже после того, как родительская функция была выполнена  
Используется, чтобы не засорять глобальную область видимости, создавая на одни и те же действия переменные для хранения данных.  
В примере пришлось бы создать много переменных `count` для разных `stepper`  
Показана возможность использования аргументов внутри замыкания, возможность изменения значений в отдельной области видимости и возвращение нескольких методов  
```javascript
function createStepper(startValue){  
	let count = startValue;
	function show(){ console.log(count) }
	return {  
		change: (changeValue) => { count += changeValue; },
		show  
	}
}
```		

Внутренняя функция имеет доступ к переменным во внешней функции.
```javascript
let stepper1 = createStepper(0) 
let stepper2 = createStepper(10) 
stepper1.change(1) 
stepper2.show() // 10  
stepper1.show() // 1
```
В переменной `stepper1` создано отдельная область видимости недоступая другому коду.  
В переменной `stepper2` создана отдельная область видимости независимая от `stepper1` с теми же функциями  

[Вернуться к содержанию](#содержание)

### 5.3 Каррирование

Трансформация функции с несколькими аргументами в серию функцию, каждая из которых принимает аргументы и возвращает функцию, которая ожидает следующий аргумент.  
Процесс продолжается, пока не будут переданы все аргументы, после чего возвращается результат выполнения исходной функции   
```javascript
const add = a => b => c => a + b + c;
const result = add(1)(2)(3);
```
Свойство `length` возвращает количество аргументов функции:
```javascript
const myFunc = function(a, b){}
console.log(myFunc.length) // 2
```
**Задача: создать функцию каррирования**
```javascript
function curry(fn, length = fn.length) {
	return (...args) => {
		if(args.length < length) {
			return curry(
				(...otherArgs) => fn(...args, ...otherArgs),
				length - args.length
			);
		}
		return fn(...args);
	}
}
function add(a, b, c) { return a + b + c }
const curriedAdd = curry(add);
curriedAdd(1)(2)(3)
curriedAdd(1, 2)(3)
curriedAdd(1)(2, 3)
curriedAdd(1, 2, 3)
```
Альтернативный метод:
```javascript
function carry(fn) {
	return (...args) => {
		return args.length >= fn.length ? fn(...args) : carry(fn.bind(null,...args))
	}
}
```

[Вернуться к содержанию](#содержание)

## 6. Массивы

[Проверка методов на мутации](https://doesitmutate.xyz/) 

* `Array.isArray(obj)` - возвращает boolean, проверка является ли переданный объект массивом(т.к. `typeof arr // 'object'`).  
**Альтернативная проверка** *`arr instanceof Array`* (принадлежность глобальному классу Array)  
Типизированные массивы возвращают false  
* `Array.from(arrayLike[, mapFn(element[, index[, array]]) { ... }[, thisArg]])` - **создает массив** из массивоподобного или итерируемого объекта (строка, NodeList. HTMLCollection, Set, Map и т.д.)    
Передаваемый "объект" должен обладать одним из двух свойств: 1) элементы должны быть проиндексированы и иметь свойство length; 2) реализован Iterable интерфейс  
При создании массива происходит поверхностное копирование  
Вместо последовательного вызова Array.from(arr).map() в качестве второго аргумента можно передать колбек-map-функции, т.о. исключается создавание промежуточного массива  
* `Array.fromAsync(arrayLike[, mapFn[, thisArg]])` - возвращает **новый массив** из асинхронного итерируемого или массивоподобного объекта  
В качестве второго аргумента можно передать колбек-map-функции, применяемый к результатам промиса.  
**Отличие от `Promise.all`:** ожидает каждое полученное значение последовательно, не дожидаясь всех значений одновременно    
**Отличие от `Array.from`:** возвращает значения промисов, а не сами промисы
```javascript
const wait = (ms) => new Promise((res) => setTimeout(() => res(ms), ms)
const promises = [wait(1000), wait(2000), wait(3000)]

const result = await Array.from(promises, (el) => element * 2)
console.log(result) // [Promise, Promise, Promise]  

const resultAsync = await Array.fromAsync(promises, (el) => element * 2)
console.log(resultAsync) // [2000, 4000, 6000]
```
[Array.fromAsync на видео](https://www.youtube.com/watch?v=7fTMx6QaFpY)  

**Добавление/удаление элементов массива**
* `arr.push(element1, ..., elementN)` - добавляет элемент(ы) в конец массива (возвращает  arr.length)  
* `arr.pop()` - удаляет элемент с конца массива (возвращает удаляемый элемент, если элементов нет - undefined)  
* `arr.shift()` - удалляет элемент из начала массива (возвращает удаляемый элемент, если элементов нет - undefined)  
* `arr.unshift(element1, ..., elementN)` - добавляет элемент(ы) в начало массива (возвращает arr.length)  
>_`unshift` - "тяжелая" операция, так как происходит сдвиг всех элементов_  

**Обнуление массива:**
* `arr = []`
* `arr.length = 0`
* `arr = new Array()`  

**Создание массива из переданных аргументов:**
* `Array.of(element0[, element1[, ...[, elementN]]])`
* `new Array(element0[, element1[, ...[, elementN]]])`  
>Отличие при передаче одного аргумента: `Array.of(2) // [2]`, `new Array(2) // [ , ]`

---

* `arr.at(index)` - возвращает элемент с заданным индексом  `arr.at(-1)` - сокращенная запись `arr[arr.length-1]`
* `delete arr[index]` - удаляет элемент без сдвига элементов (длина сохраняется)  
* `arr.fill(value[, start = 0[, end = this.length]])` - заполняет массив значениями `value` с начального до конечного (не включительно) индекса  
* `arr.includes(searchElement[, fromIndex = 0])` - возвращает boolean. Cодержит ли массив заданный элемент, начиная с начала(или с заданной позиции)
* `arr.join([separator])` - возвращает строку, состоящую из объединения всех элементов массива с указанным разделителем (или (,) по умолчанию)  
>Элементы `null, undefined` превращаются в пустую строку

* `arr.concat(value1[, value2[, ...[, valueN]]])` - возвращает **новый массив**, как объединение переданных элементов/массивов  
* `arr.slice([begin[, end]])` - возвращает **новый массив**, содержащий копию части исходного массива с индекса `start` до конца массива или строго до `end`  
* `arr.with(index, value)` - возвращает **новый массив**, заменив в исходном элемент с индексом `index` на значение `value`  
>При вызове метода преобразует все пустые элементы в undefined
* `arr.copyWithin(target, start[, end = this.length])` - копирует (поверхностно) элементы исходного массива в позицию `target` с позиции `start` до `end`  

[Скорость выполнения](https://www.measurethat.net/Benchmarks/Show/8639/0/array-concat-vs-spread-operator-vs-push-vs-object-assig)

---

* `array.splice(start[, deleteCount[, item1[, item2[, ...]]]])` - возвращает массив удаленных элементов. Исходный массив **мутирует** - удаляется целое число `deleteCount` элементов и вставляются новые элементы `item1...N`, начиная с индекса `start`  
* `array.toSpliced(start[, deleteCount[, item1[, item2[, ...]]]])` - аналог `splice`. Возвращает **новый измененный массив**, не мутирует исходный  
>При вызове метода преобразует все пустые элементы в undefined
* `arr.sort(compareFunction(a,b){})` - возвращает отсортированный **исходный массив**. `compareFunction` - должна возвращать значения: `>0`(a перед b), `0`(без изменений), `<0`(b перед a)  
>undefined не сравниваются `compareFunction` и попадают в конец массива
* `arr.toSorted(compareFunction(a,b){})` - аналог `sort`. Возвращает **новый измененный массив**, не мутирует исходный 
* `array.reverse()` - возвращает **исходный массив** с обратным порядком следования элементов  
* `array.toReversed()` - аналог `reverse`. Возвращает **новый измененный массив**, не мутирует исходный 

---

* `arr.map(callbackFn(element[, index[, array]]) {return ... код}[, thisArg]);` - возвращает **новый массив** с результатом вызова переданной колбек-функции над каждым элементом исходного массива. Исходные элементы не меняются  
Колбек-функция всегда **должна возвращать результат**  
Колбек-функция не вызывается для пустых элементов. Решение: `[...arr].map()`
* `arr.forEach(callbackFn(element[, index[, array]]) { ... }[, thisArg]);` - **выполняет** указанную колбек-функцию для каждого элемента, не изменяя исходный массив  
Применяется к **массивоподобным сущностям** (строка, NodeList, HTMLCollection и т.д.)  
_Отличие от обычного цикла:_ `forEach` нельзя прервать средствами `break/continue/return`  
_Отличие от `map`:_ `forEach` возвращает void, поэтому к нему нельзя присоединить по цепочке другие методы массива  
* `array.reduce(callbackFn(accumulator, element[, index[, array]]){return ... код}[, startValue])` - **возвращает одно значение** `accumulator`, как результат выполнения колбек функции над каждым элементом исходного массива  
Колбек-функция всегда **должна возвращать результат**, который станет значением `accumulator` в новой итерации  
`startValue` - начальное значение `accumulator` (по умолчанию: первый элемент массива). Рекомендуется указывать всегда для исключения ошибки при передаче пустого массива
>Если необходимо вернуть массив или объект, то начальное значение задавать **обязательно** (вид начального значения: `[] или {}`)  
* `array.reduceRight(callbackFn(accumulator, element[, index[, array]]){return ... код}[, startValue])` - аналог `reduce`, но вычисления идут справа налево  

[Скорость выполнения](https://www.measurethat.net/Benchmarks/Show/26792/0/performance-of-javascript-foreach-map-and-reduce-vs-for)  

---

* `arr.every(callbackFn(element[, index[, array]])[, thisArg])` - возвращает boolean, проверяя удовлетворяют ли все элементы в массиве условию в колбек-функции.  
* `arr.some(callbackFn(element[, index[, array]])[, thisArg])` - возвращает boolean, проверяя удовлетворяют ли хотя бы один элемент в массиве условию в колбек-функции.  
> Проверка пустого массива вернет в методах `every, some` вернет true     
* `arr.filter(callbackFn(element[, index[, array]]) { ... }[, thisArg])` - **возвращает новый массив** с отфильтрованными элементами  
* `arr.find(callbackFn(element[, index[, array]]) { ... }[, thisArg])` - возвращает значение первого найденного в массиве элемента удовлетворяющего условию колбек-функции или undefined  
* `arr.findLast(callbackFn(element[, index[, array]]) { ... }[, thisArg])` - аналог `find`, но поиск ведется с конца 
* `arr.findIndex(callbackFn(element[, index[, array]]) { ... }[, thisArg])` - возвращает индекс в массиве, если элемент удовлетворяет условию колбек-функции или -1   
* `arr.findLastIndex(callbackFn(element[, index[, array]]) { ... }[, thisArg])` - аналог `findIndex`, но поиск ведется с конца
>`callbackFn` в методах `every, some, filter, find, findLast, findIndex, findLastIndex` должна возвращать boolean для исключения неявного преобразования    
* `arr.indexOf(searchElement[, fromIndex = 0])` - возвращает индекс первого вхождения указанного значения, начиная от начала к концу(с индекса fromIndex). -1, если не найдено  
* `arr.lastIndexOf(searchElement[, fromIndex = arr.length])` - возвращает индекс последнего вхождения указанного значения, начиная с конца к началу(с индекса fromIndex). -1, если не найдено   
**Отличие двух последних методов от findIndex** в том, что аргументом передается элемент, а не callback-функция  
Это не позволяет искать элемент в массиве объектов, т.к. сравниваются ссылки

---

* `arr.flat(depth = 1)` - **возвращает новый массив**, уменьшая уровень вложенности массива на указанную глубину `depth`.  
При неизвестной глубине можно передать Infinity, чтобы сделать массив абсолютно плоским  
```javascript
const nestedArray = [1, [2, [3]]] 
nestedArray.flat(2) // [1, 2, 3]
``` 
* `arr.flatMap(callbackFn(element[, index[, array]]) { ... }[, thisArg])` - аналог `.map.flat(depth = 1)`.  
За один проход по массиву уменьшает вложенность на 1 и делает преобразование над элементами исходного массива  

>Во всех методах, где есть необязательный параметр `thisArg` **можно передать контекст.**  
Если колбек-функция - **стрелочная** (не имеющая собственного контекста), то передача контекста **не повлияет** на нее    

* `arr.values()` - возвращает итератор массива, со _значениями_ каждого элемента исходного массива  
* `arr.keys()` - возвращает итератор массива, с _ключами_ каждого элемента исходного массива  
* `arr.entries()` - возвращает итератор массива, с _парами ключ/значение_ каждого элемента исходного массива  
```javascript
const arr = ['a', 'b']  
arr.entries() // [0, 'a'], [1, 'b']
```

[Вернуться к содержанию](#содержание)

### 6.1 Типизированные массивы    

_Частичный разбор темы_  
JS-движок автоматически контролирует выделение памяти под переменные. Можно реализовать это в ручном режиме с помощью типизированных массивов.  
Однако данные в них хранятся **только** в бинарном виде _(узконаправленный case)_  

**ArrayBuffer** - создает объект **байтов** в памяти заданной длинны. Его содержимое нельзя напрямую изменить.  
```javascript
const buffer = new ArrayBuffer(length, options)
instanceof buffer // ArrayBuffer  
```
Свойства: 
* buffer.detached - определяет был ли буфер перемещен (transfered) (boolean)  
* buffer.byteLength - длина буфера в байтах  
* buffer.maxByteLength - максимальная длина буфера в байтах (опционально задается при создании буфера. Значение **НЕ изменяемо**)  
* buffer.resizable - определяет может ли изменяться длина буфера (boolean)  
При создании буфера в опциях можно передать `maxByteLength`, что разрешит увеличить длину буфера (свойство resizable)
`const buffer = new ArrayBuffer(8, { maxByteLength: 16 }) `

Методы:
* `ArrayBuffer.isView(value)` - определяет является ли переданный в `value` вид буфером. boolean  
* `buffer.resize(newLength)` - изменение длины буфера в байтах (`newLength` не должна превышать `maxByteLength`)
* `buffer.slice(start, end)` - возвращает копию буфера с начальной до кончной позиции  
* `buffer.transfer([newByteLength])` - создает новый буфер с заданной длиной `newByteLength`(по умолчанию: с той же длиной) c тем же содержимым, удаляя (detached) старый   
Длина не может быть больше `maxByteLength`  
* `buffer.transferToFixedLength(newByteLength)` - аналог `transfer`, но создает НЕ-изменяемый буфер `newByteLength` может быть больше `maxByteLength`  

**DataView** - разбивает данные (поток нулей и единиц) из ArrayBuffer на блоки  
`const view = new DataView(buffer, byteOffset, byteLength)`  

Свойства (только для чтения):  
* buffer - ArrayBuffer на который ссылается представление,  
* byteOffset - смещение представления в байтах от начального значения в ArrayBuffer,  
* byteLength - размер представления в байтах  

[Курс по ArrayBuffer ч1](https://habr.com/ru/companies/ruvds/articles/331344)  
[Курс по ArrayBuffer ч2](https://habr.com/ru/companies/ruvds/articles/331760)  
[Курс по ArrayBuffer ч3](https://habr.com/ru/companies/ruvds/articles/332194)  

**Задача:** создать функцию map через reduce
```typescript
type MapFunction<T, U> = (el: T, ind: number, arr: T[]): U

function myMap<T, U>(arr: T[], cb: MapFunction<T, U>): U[] {
	return arr.reduce((acc: U[], el: T, ind: number, arr: T[]) => {
		acc.push(cb(el, ind, arr));
		return acc
	}, [])
}
``` 

[Вернуться к содержанию](#содержание)

## 7. Объекты

[Подробно про объекты](https://www.youtube.com/watch?v=ACXQO1YZOXI)  
[Работа с keys, values, entries, enumerable](https://www.youtube.com/watch?v=Ha2geO5Qw_Q)  
[Очень коротко, основные фишки](https://www.youtube.com/watch?v=NsLJ_GBU-A4)  

Создание полей (в качестве ключей может быть только тип string, остальные типы неявно приводятся (`{ [{}]: {} } // -> { '[object Object]': {} }`):  
```javascript
obj = { 
	name, // упрощенное создание свойства, когда ключ и значение совпадают (name: 'name')  
	age: 80, // стандартное создание свойства  
	['hair color']: 1990, // обращение к свойствам с пробелами строго через []: obj[hair color]  
	[variable]: true // в скобочной нотации можно использовать переменные  
}
```
 
Создание методов:  
```javascript
obj = {  
	method: function(){},  
	shortMetod() {} // сокращенная запись  
}  
```
 
Добавление / изменение свойств существующего объекта:  
```javascript
obj.name = 'Petr'  
obj[method] = () => {} // к значению переменной method применяется toString  
obj['age'] = 18
```  

Вызов свойства:
```javascript
obj.name  
obj[variable] // let variable = 'city'    
obj['age']
``` 

Удаление свойства:
```javascript
delete obj.name  
delete obj.[variable] // let variable = 'city' 
delete obj.['age']
```

Массивы и функции являются объектами, поэтому могут иметь **именованные свойства**:  
```javascript
const arr = [];  
arr.name = 'Petr'

function myFunc(){};  
func.name = 'Petr' // наличие таких свойств у функции не нарушает ее выполнение  
```  
Для **скрытия свойств** в объекте можно воспользоваться Symbol:  
Свойства заданные через Symbol скрыты от циклов и методов: `for..in, Object.keys, Object.values, Object.entries, getOwnProperty`  
```javascript
let variable = Symbol("name")  
let obj = {[variable]: 'Petr'}
```

---

* `Object.is(value1, value2)` - строгое сравнение переданных значений (boolean)  
>Альтернативный способ проверки равенства `NaN`: `Object.is(NaN, NaN) // true`. См. примеры в [4.2 Числа (Number, BigInt)](#42-числа-number-bigint)
* `Object.values(obj)` - возвращает **массив** значений перечисляемых **собственных (не прототипа) свойств** объекта  
* `Object.keys(obj)` - возвращает **массив** ключей перечисляемых **собственных (не прототипа) свойств** объекта  
* `Object.entries(obj)` - возвращает **массив** пар ключ-значение перечисляемых **собственных (не прототипа) свойств** объекта  
* `Object.fromEntries(iterable)` - возвращает объект на основе списка пар ключ-значение. `Object.fromEntries([['name', 'Petr'],['age', 18]])`  
Аргумент - объект реализующий Iterable интерфейс (Map, Set и т.д.)  
* `Object.toString()` - возвращает строковое предсавление объекта (стандартно Object[object])
Можно переопределить через `Symbol.toPrimitive`, `prototype.toString` или в самом классе/конструкторе
* `'property' in obj` - наличие свойства `property` в объекте **и его прототипе**  
* `obj.hasOwnProperty(prop)` - наличие свойства в объекте, **но не в прототипе**  
* `Object.hasOwn(obj, prop)` - аналог устаревшего `hasOwnProperties`  
```javascript
const obj = { name: 'Petr'}  
'name' in obj // true  
Object.hasOwn(obj, 'name') // true  
obj.hasOwnProperty(obj, 'name') // true  

const obj = { name: 'Petr'}   
'toString' in obj // true  
Object.hasOwn(obj, 'toString') // false  
obj.hasOwnProperty(obj, 'toString') // false  

const obj = Object.create(null)  
obj.age = 21  
'age' in obj // true  
Object.hasOwn(obj, 'age') // true  
obj.hasOwnProperty(obj, 'age') // false  
```
[Отличие hasOwn от hasOwnProperty (vpn)](https://javascript.plainenglish.io/in-vs-hasown-vs-hasownproperty-in-javascript-885771d2d100)  
[Отличие hasOwn от hasOwnProperty на русском](https://www.dev-notes.ru/articles/javascript/check-if-a-object-property-exists/)  

* `Object.groupBy(items, callbackFn(element, index){})` - группирует свойства итерируемого объекта способом указанным в колбек-функции   
>Колбек-функция всегда должна возвращать строку с ключом группировки
```javascript
const persons = [
	{name: 'Petr', age: 16},
	{name: 'Olga', age: 18},
	{name: 'Pavel', age: 20}
]
const groupedByAge = Object.groupBy(persons, ({age}) =>  age < 18 ? 'young' : 'old');
/* {
		"young" : [ {name: 'Petr', age: 16} ],	
		"old" : [ {name: 'Olga', age: 18}, {name: 'Pavel', age: 20} ] 	
} */ 
```
* `Object.assign(target, ...sources)` - копирует **собственные перечисляемые** свойства объектов `source` в объект `target`  
**Копирование поверхностное. В отличие от spread сохраняет прототип объекта**

[Вернуться к содержанию](#содержание)

### 7.1 Поверхностное и глубокое копирование  

Для создания объекта, несвязанного с изначальным, необходимо скопировать его данные:  
При копировании данных объектов или массивов происходит **поверхностное копирование** (копируются ссылки на вложенные объекты, а не значения)  
1. `const obj2 = Object.assign({}, obj1)`
2. `const obj2 = {...obj1}`    
3. инициализируем новый объект с теми же данными: `const obj1 = {a: 1}, obj2 = {a: 1} // obj1 !== obj2`   

Отличие первых двух методов копирования:
* Количество кода
* Spread не копирует прототип исходного объекта в целевой объект, а Object.assign сохраняет прототип  

**Пример 1**  
```javascript
const error = new Error();
console.log(error instanceof Error); // true

const errorSpread = { ...error, value: true };
console.log(errorSpread instanceof Error); // false 

const errorAssign = Object.assign({}, error, {value: true})
console.log(errorAssign instanceof Error) // также false

errorAssignTwo = Object.assign(error, {value: true})
console.log(errorAssignTwo instanceof Error) // true 
```

**Пример 2**  
```javascript
const parentObject = { childObject: { name: 'Petr '} };
const childObject = parentObject.childObject;

Object.assign(parentObject.childObject, { age: 18 });
console.log(parentObject.childObject === childObject) // true

parentObject.childObject = {...parentObject.childObject, age: 18} // создали новый объект
console.log(parentObject.childObject === childObject); // false
```

**Способы глубокого копирования:**
* structuredClone(obj) // поддержка на 90%
* JSON.parse(JSON.stringify(obj)) // данные должны быть сериализуемы (undefined, функции, Symbol превратятся в undefined)  
* Object.assign рекурсивное копирование вложенных объектов  
* метод cloneDeep библиотеки lodash

[Вернуться к содержанию](#содержание)

### 7.2 Дескрипторы свойств

Свойства объекта кроме значения имеют 3 флага конфигурации (общие: configurable и enumerable; **дескриптор данных**: value и writable):
* value - значение свойства  
* writable - возможность перезаписи значения свойства  
* enumerable - возможность перечисления свойства, например в цикле for..in   
* configurable - возможность переопределения флагов свойства и удаления свойства  
При "обычном" создании свойства все 3 флага установлены в true  

Дескриптор бывает 2 видов: **дескриптор данных и дескриптор доступа**.  
**Дескриптор доступа** - дескриптор определяющий работу через функции геттера и сеттера  
Имена геттера/сеттера и используемой переменной **должно отличаться**: propName и name, property и _property  
>Нельзя использовать разные виды дескрипторов одновременно для одного свойства  

Для работы с дескрипторами используются методы:  

* `Object.defineProperty(obj, prop, descriptor)` - определяет новый или изменяет существующий дескриптор свойства объекта (отсутствующие флаги в дескрипторе имеют значение по умолчанию: false)  
* `Object.defineProperties(obj, props)` - определяет новые или изменяет существующие дескрипторы нескольких свойств объекта  
```javascript
const obj = {_city: 'Moscow'}
Object.defineProperties(obj, { 
	name: { 
		value: 'Petr', 
		writable: true,
		enumerable: true,
		configurable: true 
	}, 
	age: { 
		value: 18, 
		writable: false,
		enumerable: true,
		configurable: true 
	} 
})
Object.defineProperty(obj, 'age', { value: 21, writable: true })
// Отсутствие сеттера запрещает перезапись свойства - readonly    
Object.defineProperty(obj, 'city', { configurable: true, get: function() { return this._city.toUpperCase()} })
```  
Дескриптор доступа можно передать напрямую в объект: 
```javascript
const person = {
	get name() {
		return this._name
	}
	set name(value) {
		this._name = value.trim()
	}
}
```
* `obj.propertyIsEnumerable(prop)` - проверяет является ли свойство перечисляемым (boolean) 
* `Object.preventExtensions(obj)` - запрещает добавлять новые свойства в объект  
* `Object.seal(obj)` -  запрещает добавлять и удалять свойства, делает все свойства неконфигурируемыми  
* `Object.freeze(obj)` - запрещает добавлять, удалять и изменять свойства  
*Три данных метода возвращают ссылку на объект. Методы можно применять без присваивания*  
>Заморозка поверхностная. Ссылочные типы данных можно мутировать  
Для создания полностью иммутабельного объекта необходимо реализовать [`deepFreeze()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)  
* `Object.isExtensible(obj)` - определяет можно ли к объекту добавить новые свойства (применен ли один из трех методов выше) (boolean)    
* `Object.isSealed(obj)` - определяет применен ли к объекту `seal` (boolean)  
* `Object.isFrozen(obj)` - определяет применен ли к объекту `freeze` (boolean)  

* `Object.getOwnPropertyDescriptor(obj, prop)` - возвращает дескриптор собственного свойства  
* `Object.getOwnPropertyDescriptors(obj)` - возвращает массив дескрипторов всех собственных свойств (независимо от того перечисляемые они или нет) 
* `Object.getOwnPropertyNames(obj)` - возвращает массив строк, содержащих имена собственных свойств
* `Object.getOwnPropertySymbols(obj)` - возвращает массив всех собственных символьных свойств объекта 
>Единственный из 4 методов, который возвращает Symbol

[Вернуться к содержанию](#содержание)

### 7.3 Прототип объекта

**Прототип объекта** - механизм с помощью которого объекты наследуют свойства друг друга  
При обращении к свойству, которое не определено в объекте, будет произведен поиск в цепочке прототипов объекта, пока свойство не будет найдено или undefined  

* `Object.create(proto[, propertiesObject])` - создает объект с указанным прототипом и свойствами, переданными в формате дескрипторов 
**Передаваемый дескриптор может быть только одного типа**    
```javascript
Object.create(obj.prototype, {  
	name: {  
		value: 'Petr',  
		configurable: true  
	}  
})
``` 
* `Object.getPrototypeOf(obj)` - возвращает прототипа объекта
* `Object.setPrototypeOf(obj, prototype)` - переопределение прототипа объекта  
Переопределение прототипа сильно влияет на производительность  
*Можно получить/переопределить прототип через встроенное свойство `obj.__proto__` , но способ устаревший*  
* `obj instanceOf NewObject` - проверка принадлежности к функции конструктору [5.1 Контекст функции](#51-контекст-функции)    
* `prototypeObj.isPrototypeOf(object)` - проверяет является ли объект прототипом для другого объекта (создание через Object.create)  
>**Отличие от instanseof**: isPrototypeOf - проверяет прототип, а не класс/конструктор. Проверка объекта созданного через `Object.create` способом `instanseof` выдаст **ошибку**  

[Вернуться к содержанию](#содержание)

### 7.4 Опциональная цепочка

**Опциональная цепочка** - позволяет проверить наличие свойства в объекте в цепочке методов  
Если свойство отсутствует - код не упадет с ошибкой. Возвращает undefined, если значение перед `?` равно undefined или null  
```javascript
obj.nestedObj.name // **выдаст ошибку**, если нет вложенного объекта nestedObj
obj?.nestedObj?.name
obj.method?.() // проверка существования метода объекта  
obj?.[key] // проверка существования поля объекта  
delete obj?.prop // пример с удалением  
document.querySelector('#input_id')?.classList.add() // пример работы с DOM
```

[Вернуться к содержанию](#содержание)

## 8. Итераторы и генераторы

### 8.1 Итератор  

[Видео-пример итераторов](https://www.youtube.com/watch?v=CDpBHAwFsog)  
[Хороший разбор](https://www.youtube.com/watch?v=HToDur7Gkkw)  

Специальная конструкция позволяющая сделать неитерируемый объект, например object, перебираемым.  
Для создания iterable-интерфейса объекта, нужно:  
1. задать объекту `Symbol.iterator`  
2. символ должен вернуть метод `next()`  
3. next() возвращающий объект со свойствами `value` и `done`, где `value` - перебираемое значение, `done` - статус выполнения перебора  
```javascript
const obj = {  
	name: 'Alex',  
	age: 18,  
	sex: 'male',  
	[Symbol.iterator] () {  
		// this пробрасываем в функцию, т.к. this вызывается в методе next, у которого свой контекст.  
		const $this = this; 
		const keys = Object.keys(this);  
		const lastIndex = keys.length;  
		let nextIndex = 0; 
		return { 
			next() {
				return nextIndex < lastIndex ? {done: false, value: $this[keys[nextIndex++]]} : {done: true}
			}
		}  
	}  
}
for(let item of obj){ console.log(item) }
```

Создание итератора на основе функции-конструктором:  
```javascript
function MakeIterator {
	...определение конструктора и вспомогательных переменных
	return {
		next: function() {},
		[Symbol.iterator]() {
      return this;
    }
	}  
}  
```

По умолчанию Iterable интерфейс реализован в: `String, Array, Map, Set`  
Итератор позволяет применить к итерируемой сущности: деструктуризацию, преобразование `Array.from`, оператор `spread`    

[Вернуться к содержанию](#содержание)

### 8.2 Генератор

Генератор - особый вид объекта-итератора, который дополнительно реализует метод `throw()` и `return()`  
Для объявления функции генератора используется символ `*`:  
```javascript
function* myGenerator() {}
function * myGenerator() {}
function *myGenerator() {}
``` 
Операторы `yield`, `yield*` возвращают значение и приостанавливают выполнение функции с полным сохранением промежуточных вычислений  
`yield*` перенаправляет итерацию в другой генератор  
Оператор `yield` используется в самой функции-генератора, _использование в колбеке приведет к ошибке_  

```javascript
function* getNames() {
	yield 'Petr';
	yield: 'Olga'
}

const generator = getNames()
generator.next() // {value: 'Petr', done: false}
generator.next() // {value: 'Olga', done: false}
generator.next() // {value: undefined, done: true}
```
Добавление `return` внутри генератора завершает его на текущей итерации.
```javascript
function* getNames() {
	yield 'Petr';
	return: 'Olga'
}
generator.next() // {value: 'Petr', done: false}
generator.next() // {value: 'Olga', done: true}
```
Проверка является ли генератор итерируемым объектом: `generator[Symbol.iterator]() === generator) // true`,   
т.к. генераторы являются итераторами и при вызове метода `[Symbol.iterator]` возвращают сами себя  

**Передача аргументов в генераторы:**  
```javascript
function* getNames() {
	const isMale = yield 'Greetings'
	if(isMale) yield 'Petr'
	else yield 'Olga'
}
const generator = getNames()  
// первый вызов - инициализация генератора
generator.next() // {value: 'Greetings', done: false}
generator.next(true) // {value: 'Petr', done: false}
```

**Перенаправление в генераторе**  
```javascript
function* maleNames() {
	yield 'Petr'
	yield 'Sergey'
}

function* getNames() {
	const isMale = yield 'Olga'
	// перенаправляем работу текущего генератора в новый
	if(isMale) yield* maleNames
	else yield 'Elena'
	yield 'Maria'
}
const generator = getNames()
generator.next() {value: 'Olga', done: false}
generator.next(true) {value: 'Petr', done: false}
generator.next() {value: 'Sergey', done: false}
generator.next() {value: 'Maria', done: false}
```

Метод `throw()` - выбрасывает ошибку, которая может быть перехвачена в генераторе. Генератор не завершает работу  
Метод `return(value)` - завершает выполнение функции и возвращает переданное значение `value`  
```javascript
function* getNames() {
	try {
		yield 'Petr';
		yield 'Olga';
		yield 'Pavel';
	} catch (error) {
		console.log(Something went wrong, error.message)
	}
	yield 'Kate';
	yield 'Sam';
}

const generator = getNames();
console.log(generator.next()); // { value: 'Petr', done: false }
console.log(generator.throw(new Error('Error'))); // "Something went wrong" "Error"
console.log(generator.next()); // { value: 'Pavel', done: false }
console.log(generator.return('Stop generator')); // { value: 'Kate', done: false } { value: 'Stop generator', done: true }
console.log(generator.next()); // { value: undefined, done: true }
```

[Вернуться к содержанию](#содержание)

## 9. Spread синтаксис и деструктуризация

### 9.1 Spread

Spread - расширяющий синтаксис `...`, позволяющий развернуть итерируемый объект.  
Применение:

* Копирование (поверхностное):  
```javascript
let arr = [...arr1]
let obj = {...obj1} 
```
* Конкатенация:  
```javascript
const arr1 = [a, b], arr2 = [c, d]  
const arr = [1, ...arr1, ...arr2] // [1, a, b, c, d] 

let obj = {...obj1, ...obj2}
```
* Использование значений массива как аргументов функции:  
```javascript
let arr = [a, b]
function myFunc(arg1, arg2){} 
myFucn(...arr)
```
* Преобразование строки в массив: `let variable = [...'string']`  
* Конвертации псевдомассивов (NodeList, HTMLCollection и т.д.) в массив: `[...nodeList]`  
`[...new Set(array)]` - создание массива уникальных элементов  
* Конвертация массива в объект: `{...arr}`

[Вернуться к содержанию](#содержание)

### 9.2 Rest 

Rest использует тот же spread-синтаксис, для сбора оставшихся аргументов в массив  
Применение:
* Сбор оставшихся аргументов функции  
```javascript
function f1(a, ...rest) { }; // неопределенное число аргументов при объявлении функции  
f1(1,2)` // Expected 1 и [2]  
f2(1,2,[3,4],true,'a') // Expected 1 и [2,[3,4],true,'a']
```
* Сбор оставшихся аргументов при деструктуризации `let [a, b, ...rest] = [1, 2, 3, 4] // a = 1 b = 2 rest = [3, 4]`

[Вернуться к содержанию](#содержание)

### 9.3 Деструктуризация

Деструктуризация переменных - синтаксис, позволяющий распаковывать объекты/массивы в несколько переменных.  
Синтаксис: `let [<переменные>] = [<значения переменных>] или {<переменные>} = {<значения переменных>}`

* **Деструктуризация массивов** (работает с любыми итерируемыми объектами: Map, Set String, Array, кастомный Iterable объект, TypedArray и т.д.):  
```javascript
const [name, age, city] = ['Petr', 21] // name -> 'Petr'; age -> 21; city -> undefined

// пропуск нежелательных переменных с помощью (,) и установка значения по умолчанию    
const [,, age, name = 'Petr'] = ['Moscow', 1990, 21] 

// присваивать свойств объекту  
const obj = {}
[obj.name, obj.age] = ['Petr', 18] 

// деструктуризация в цикле
for(let [key, value] in Object.entries(obj) {} 

// обмен значениями переменных  
let guest = 'Petr', admin = 'Olga'  
[admin, guest] = [guest, admin] 
```
 
* **Деструктуризация во вложенных массивах**: `const [var1, [var2, var3 = 'default']] = [a, [12]]` 
* **Деструктуризация объектов**:  
```javascript
const {age, name} = {name: 'Petr', age: 18} // имена переменных должны совпадать со свойствами объектов, последовательность не важна
```

* **Переопределение названий переменных**: 
Одновременно с переопределением можно указать значение по умолчанию  
`const {city: address = 'Moscow', name: fullName, ...other} = {city: 'Ivanovo', name: 'Petr', age: 18}`
В *other* останутся неиспользованные в деструктуризации свойства объекта  

* **Деструктуризация во вложенных объектах**: `const {nestedObj: {var2 = 'default'}} = {var: '', nestedObj: {var2: ''}}`

* **Деструктуризация массивов в функции**:  
```javascript
function func([city, name, age = 18]) {}  
func(arr)  
```  

* **Деструктуризация объектов в функции**  
```javascript
function func({name = 'Petr', age, city: town = 'Moscow'}) { 
	return {name, age} 
}  
const {name, age} = func(obj)
```

[Вернуться к содержанию](#содержание)

## 10. Map, Set  

https://www.youtube.com/watch?v=eiERfNjeeUc  
https://www.youtube.com/watch?v=mbcP3Oc0PjU - подробнее (минин)  

Коллекции реализуют Iterable интерфейс, поэтому их можно использовать в циклах, применять spread (`[...mapCollection]`) и т.д.  
**Отличие от объектов**: 
1. В качестве ключа может быть **любой тип данных** (объекты/функции/массивы/NaN и т.д.). Ключи сохраняют свой тип и НЕ преобразуются в string  
2. **Обратиться напрямую к элементу коллекции НЕЛЬЗЯ** (`mapCollection.item / mapCollection[item]` - ошибки)  
3. При итерации последовательность добавленных элементов сохраняется (в объекте зависит от браузера/среды исполнения и других договоренностей)  
4. Не сериализуются JSON (можно предварительно перевести в объект)  

[Вернуться к содержанию](#содержание)

### 10.1 Map

**Map** - коллекция для хранения данных в виде пар ключ-значение.   
**Отличие от объектов:** 
* ключами могут быть значения любого типа
* реализован Iterable интерфейс  
* нет прототипного наследования
* элементы сохраняют порядок добавления при итерации  

**Примеры инициализации**
* `const testMap = new Map([['1', 'Value with string key']])`  
* `const testMap = new Map([[1, 'Value with number key']])`  
* `const testMap = new Map([[true, 'Value with boolean key')`  
* `const testMap = new Map([[{name: 'Petr'}, 'Value with object key']])`  
* `const testMap = new Map([[NaN, 'Value with NaN key']])`  
* `const testMap = new Map([[null, 'Value with null key']])`  
* `const testMap = new Map([[undefined, 'Value with undefined key']])`  
* `const testMap = new Map([[() => {}, 'Value with object key']])`  
* `const testMap = new Map([['name', 'Petr'], ['age', 18]])` // несколько значений  
`testMap.size` - колчиество элементов в коллекции  
>При создании ключей ссылочного типа их нужно передавать в виде переменной, чтобы можно было к ним обратиться  

**Методы Map:**  
* testMap.set(key, value) - добавляет или изменяет значение элемента (возвращает коллекцию) 
```javascript
testMap.set('name', 'Petr').set('age', 18) // можно выстраивать в цепочки  
```
* testMap.get(key) - возвращает значение элемента или undefined
* testMap.delete(key) - удаляет элемент, возвращает boolean (true - удален)  
* testMap.has(key) - boolean. проверяет наличие элемента с переданным ключом  
* testMap.clear() - очищает коллекцию  
* testMap.forEach(callbackFn(element[,key[,mapCollection]])[, thisArg]) - стандартный метод forEach для коллекции Map  
* testMap.values() - возвращает итератор всех значений коллекции (в порядке добавления)  
* testMap.keys() - возвращает итератор всех ключей коллекции (в порядке добавления)  
* testMap.entries() - возвращает итератор пар ключ-значение (в порядке добавления)  
При использовании в цикле по умолчанию всегда вызывается map.entries(): `for(let [key, value] of testMap) {...}`  
Трансформация коллекции в объект: `Object.fromEntries(testMap.entries())`  
* Map.groupBy(items, callbackFn) - возвращает **`Map`** сгрупированных элементов по правилам callbackFn. Работа аналогична `Object.groupBy()`  
`items` - итерируемая сущность  
```javascript
const persons = new Map[
	{name: 'Petr', age: 16},
	{name: 'Olga', age: 18},
	{name: 'Pavel', age: 20}
]
const groupedByAge = Map.groupBy(persons, ({age}) =>  age < 18 ? 'young' : 'old');
console.log(groupedByAge.get('young') // [ {name: 'Petr', age: 16} ]
```

[Вернуться к содержанию](#содержание)

### 10.2 Set

**Set** - коллекция для хранения **уникальных** значений  
Так как Set хранит только значения, то методы `keys` и `values` выводят одинаковые результаты, а `entries` дублирует их в массиве ключ-зачение  
Они нужны только для поддержки универсального интерфейса, как у Map (поэтому используют `values`, который возвращает итератор всех значений коллекции в порядке добавления)  
Наиболее частый способ использования: получение уникальных значений массива `[...new Set(arr)]`  

Пример инициализации: `const testSet = new Set([1,1,2,3])`. Конструктор `new Set(arr)` принимает аргументом итерируемый объект  
`testSet.size` - колчиество элементов в коллекции 
Методы Set (работают аналогично методам Map): 
* `testSet.add(value)` - добавляет элемент(возвращает коллекцию, поэтому можно вызвать по цепочке)  
* `testSet.delete(value)` - удаляет элемент, возвращает boolean (true - удален)  
* `testSet.has(value)` - проверяет наличие элемента с переданным ключом  
* `testSet.clear()` - очищает коллекцию  
* `testSet.forEach(callbackFn(element[,key[,mapCollection]])[, thisArg])` - - стандартный метод forEach для коллекции Set  
* `testSet.values()` - возвращает итератор всех значений коллекции (в порядке добавления)  
* `testSet.difference(other)` - возвращает разницу между `testSet` и `other`  
```javascript
const testSet = new Set([1,3,5,7,9])
const anotherSet = new Set([1,4,9])
console.log(testSet.difference(anotherSet)) // Set(3) {3,5,7}
```
* `testSet.intersection(other)` - возвращает пересечение `testSet` с `other`  
```javascript
const testSet = new Set([1,3,5,7,9])
const anotherSet = new Set([1,4,9])
console.log(testSet.intersection(anotherSet)) // Set(2) {1,9}
```
* `testSet.symmetricDifference(other)` - возвращает симметричную разницу между `testSet` и `other`  
```javascript
const testSet = new Set([1,3,5,7,9])
const anotherSet = new Set([1,4,9])
console.log(testSet.symmetricDifference(anotherSet)) // Set(4) {3,5,7,4}
```
* `testSet.union(other)` - возвращает объединение `testSet` с `other`  
```javascript
const testSet = new Set([1,3,5,7,9])
const anotherSet = new Set([1,4,9])
console.log(testSet.union(anotherSet)) // Set(4) {1,3,5,7,9,4}
```
* `testSet.isDisjointFrom(other)` - возвращает boolean, проверяя есть ли элементы из `testSet` в `other`  
* `testSet.isSubsetOf(other)` - возвращает boolean, проверяя содержатся ли все элементы из `testSet` в `other`  
* `testSet.isSupersetOf(other)` - возвращает boolean, проверяя есть ли элементы из `other` в `testSet`

`other` - `Set` или объект похожий на `Set`, т.е. имеющий свойства `size, has, keys` (например `Map`)

[Вернуться к содержанию](#содержание)

### 10.3 WeakMap  

**WeakMap** - коллекция для хранения данных в виде пар ключ-значение, позволяющая затирать свои ключи сборщиком мусора  
Коллекция **НЕ позволяет** итерировать по своим элементам, потому что неизвестно, когда сборщик мусора удалит их.  
Элемент удаляется, если в коде он нигде не используется (нет сильных ссылок):  
```javascript
let obj = {name: 'Petr'}  
const testWeakMap = new WeakMap([obj: 'Data'])  
obj = null // удалили объект и более он нигде не используется  
testWeakMap.has(obj) // false - элемент был удален сборщиком мусора  
```

В качестве ключе коллекции WeakMap могут быть **ТОЛЬКО элементы с типом Object** (объекты, другие коллекции, массивы, функции)  
Наиболее часто используется для кэширования элементов. Если их удалят, то память в кэше автоматически освободит сборщик мусора  

Доступные методы (работают аналогично Map):  
* `testWeakMap.set(key, value)`  
* `testWeakMap.get(key)`  
* `testWeakMap.has(key)`  
* `testWeakMap.delete(key)`  

keys, values, entries, forEach, **size**, **clear** - недоступны  

[Вернуться к содержанию](#содержание)

### 10.4 WeakSet  

**WeakSet** - коллекция для хранения *уникальных* значений, позволяющая затирать свои ключи сборщиком мусора  
Коллекция **НЕ позволяет** итерировать по своим элементам, потому что неизвестно, когда сборщик мусора удалит их.  

В качестве ключа коллекции WeakSet могут быть **ТОЛЬКО элементы с типом Object** (объекты, другие коллекции, массивы, функции)  

Доступные методы (работают аналогично Set):  
* `testWeakSet.add(value)`
* `testWeakSet.delete(value)`
* `testWeakSet.has(value)`

`keys, values, entries, forEach, size, clear` - недоступны  

[Вернуться к содержанию](#содержание)

## 11. Асинхронность

Выполнение JS - однопоточное. Любая операция блокирует выполнение последующих.  
Асинхронность позволяет решить проблему блокирующего кода.  
[Асинхронность в JS. Подробно и долго](https://www.youtube.com/watch?v=x0Y3TfkvCgY)  

`for await...of` - цикл аналогичный `for...of` позволяющий итерировать асинхронные итерируемые сущности  
```javascript
async function* myGenerator() {
	for (const item of [1,2,3]) {
		await new Promise(resolve => setTimeout(resolve, 1000))
		yield item
	}
}
(async () => {
	for await (const value of myGenerator()) { console.log(value) }
})()
```

[Вернуться к содержанию](#содержание)

### 11.1 Promise

[Работа промисов на примере запросов данных](https://www.youtube.com/watch?v=0O-ZVnwbGW4)  
[Еще раз все про промисы](https://www.youtube.com/watch?v=c_iQPXDZ_l4)  
`Promise` - специальный объект для обработки асинхронного кода. Решает задачу выполнения кода в зависимости от результата асинхронной операции    
`Promise` может находиться в 3 состояниях: pending(ожидание), `fullfilled` (выполнено успешно), `rejected` (выполнено с ошибкой)  
Асинхронные функции возвращают объект `Promise` в качестве значения, в котором хранится результат вычисления  

**Использование промиса**  
Конструктор принимает колбек-функцию `executor`, которая выполняет асинхронную операцию и переводит промис в `fullfilled` или `rejected`  
В качестве аргументов передаются колбеки `resolve, reject` для перевода в соответствующие состояния  
Аргумент переданный в `resolve` будет доступен в `then`, аргумент переданный в `reject` будет доступен в `catch`  
```javascript
const myPromise = new Promise((resolve, reject) => {
	<условие успешного выполнения и завершения с ошибкой>
	resolve()
	reject()
}) 
// начало асинхронного кода
myPromise
	// выполняется в случае fullfilled, return передает аргументы дальше по цепочке
	.then((res) => {return res}) 
	.then((res) => {return res})
	//выполняется в случае ошибки любого вида в цепочке до catch 
	.catch(() => {})
	// выполняется всегда, независимо от состояния промиса 
	.finally(() => {})
	.then(() => {})
``` 
При передаче значения в `return` оно неявно оборачивается в `Promise`, для дальнейшего использования в цепочке  
При передаче `Promise` в `return` неявная обертка не вызовется  

* `.then(onFulfill, onReject)` - обрабатывает разрешенный промис, где   
	* `onFulfill` - функция-колбек вызванная при переходе промиса в состояние fullfilled
	* `onReject` - функция-колбек вызванная при переходе промиса в состояние rejected  
На практике используется только для обработки успешного завершения  
* `.catch(onReject)` - обрабатывает ошибку при выполнении асинхронной операции (rejected)  
Последним в цепочке принято использовать `catch`, чтобы он мог отловить любую ошибку выше. Ошибка в самом `catch` обрабатывается сборщиком мусора.  
Т.к. промисы одноразовые, то по окончанию их действия сборщик мусора при очистке увидит ошибку и выдаст `unhandledrejection`
* `.finally(onDone)` - выполнение кода вне зависимости от результата промиса  
Если в `finally` отсутствует возврат значения (`return`), то в следующие по цепочке блоки попадет результат из предыдущих блоков, вернувших значение (then, catch)  
`then, catch, finally` могут чейниться в **любой** последовательности.  

**Пример использования промиса:**  
```javascript
const myPromise = new Promise((resolve, reject) => {
	setTimeout(() => {  
		console.log('get data') 
		const obj = {age = 18, name = 'Petr'}
		resolve(obj)  
	}, 1500)
})  
myPromise.then(data => {
	return new Promise((resolve, reject) => {
		setTimeout(() => {  
			data.city = 'Moscow'
			resolve(data)
		}, 2000)
	})
})
.then(updatedData => { console.log(updatedData) })
```  

`Promise.resolve / Promise.reject` - статические методы, которые сразу создают исполненный или отклоненный промис  
При передаче `Promise` в `Promise.resolve` он вернет его без изменений:  
```javascript
const promise = Promise.resolve('Petr')
const resolved = Promise.resolve(promise) 
console.log(promise === resolved) // true
resolved.then((value) => { console.log(value) }) // 'Petr'
```
При передаче `Promise` в `Promise.reject` он вернет как отдельный `Promise`, не распаковывая:
```javascript
const promise = Promise.resolve('Petr')
const resolved = Promise.reject(promise)
console.log(promise === resolved) //false  
resolved.catch((value) => { console.log(value) }) // Promise {<resolved>: Petr }
```

* `Promise.all([promise1, promise2, ...promiseN]).then(() => {})` - параллельно запускает несколько промисов и ожидает их выполнения  
Возвращает промис, который выполнится при выполнении всех промисов или отклонится при отклонении любого промиса  
```javascript
Promise.all([Promise.resolve('Petr'), 'Olga'])
.then((value) => { 
	console.log(value)` // ['Petr', 'Olga'] 
})
```
**Задача:** написать собственный `Promise.all`  
```javascript
const myPromiseAll = async (promises) => {
  return new Promise((res, rej) => {
    const result = []
    const resolvedPromises = 0;
    promises.forEach((promise, index) => {
        promise
          .then(res => {
            result[index] = res;
            resolvedPromises++
            if(resolvedPromises === promises.length) res(result)
          })
          .catch(err => rej(err))
      })
    }             
  })
}
```
* `Promise.allSettled([promise1, promise2, ...promiseN])` - параллельно запускает несколько промисов и ожидает их выполнения   
Возвращает промис, который разрешается, когда все промисы будут завершены (успешно или с ошибкой)  
Результат: массив объектов с информацией о состоянии каждого промиса
```javascript
const promises = Promise.allSettled([Promise.resolve('Petr'), Promise.reject('Olga')])
promises.then(res => console.log(res)) // [ {"status": "fulfilled", "value": "Petr"}, {"status": "rejected", "reason": "Olga"} ]
```
* `Promise.any([promise1, promise2, ...promiseN])` - параллельно запускает несколько промисов и ожидает первый успешно выполненный  
Возвращает промис, который выполнится, если любой из массива промисов выполнится. Если все промисы завершаются с ошибкой, завершается с ошибкой AggregateError
* `Promise.race([[promise1, promise2, ...promiseN])` - параллельно запускает несколько промисов и ожидает первый завершенный промис (с ошибкой или без)   
Возвращает промис, который выполнится если первый завершенный промис завершится успешно или отклонится, если первый завершенный промис завершится с ошибкой  
**Нельзя передавать пустой массив!** иначе промис зависнет не получив исполненного промиса или значения  
* `Promise.withResolvers()` - метод, возвращающий объект {promise, resolve, reject}  
Является упрощением записи:  
```javascript
let resolve, reject;
const promise = new Promise((res, rej) => {
  resolve = res;
  reject = rej;
});
```
[Разбор с примером](https://www.youtube.com/watch?v=8Guo321ACcU)

При передаче в методы не промиса, а значения любого типа (текст, число и т.д.) оно вернется раньше любого промиса, т.к. уже вычислено 
>Чтобы избежать зависания промисов можем обернуть методы в Promise.race, добавив в него reject по таймеру, который вернется, если за время таймера остальные промисы не успели исполниться  

[Кастомный Promise с нуля](https://www.youtube.com/watch?v=rJ5u7rsMU6g)  

[Вернуться к содержанию](#содержание)

### 11.2 Async, await  

Альтернативный упрощенный синтаксис для работы с промисами  
Функция маркируется асинхронной: `async function fetchData() {}`. Возвращаемое значение автоматически оборачивается в промис  
Ключевое слово `await`, используемое внутри асинхронной функции позволяет дождаться выполнения асинхронной операции  
```javascript
const fetchData = async () => {
	const response = await fetch('http://jsonplaceholder.typicode.com/posts');
	const data = await response.json();
	return data;
}
fetchData().then(res => {console.log(res)})
```  
Использование `await` в модулях:  
```javascript
// child
const promise =  new Promise();
export const data = await promise

// parent
// родительский модуль ожидает завершения асинхронной операции в импортируемом модуле
import {data} from 'child'
```

[Вернуться к содержанию](#содержание)

### 11.3 fetch

`fetch(url[, options])` - асинхронный метод, который позволяет отправлять сетевые запросы на сервер, где  
* url - адрес запроса
* options - необязательный объект конфигурации запроса [Список свойств](https://developer.mozilla.org/en-US/docs/Web/API/Request)  
Метод возвращает промис со специальным объектов `Response`, содержащим поля:  
* ok - boolean. Статус успешности запроса
* json - метод, возвращающий результат запроса в формате json
* [Список остальных свойств](https://developer.mozilla.org/en-US/docs/Web/API/Response)
```javascript
const data = {
	name: 'Petr',
	age: 18
}
fetch('http://jsonplaceholder.typicode.com/posts', {
	method: 'POST',
	body: JSON.stringify(data),
	headers: {
		'Content-type': 'application/json'
	}
	// включение coockies в запрос
	credentials: 'include'
})
	.then(res => res.json())
	.then(res => console.log(res))
```

Для прерывания запроса необходимо создать экземпляр `AbortController` и передать `signal` в `options`:
```javascript
const controller = new AbortController()

const fetchData = fetch('http://jsonplaceholder.typicode.com/posts', {signal: controller.signal}).then().catch()
fetchData()
// прерывание
controller.abort()
```

Для загрузки файлов используются интерфейсы: [ReadableStream](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream), [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob), [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)
Альтернативный способ - библиотека Axios (Axios.md). Под капотом используется `XMLHttpRequest` для совместимости со старыми браузерами  

[Вернуться к содержанию](#содержание)

### 11.4 Таймеры

[Подробно про setTimeout, setInterval](https://youtu.be/6cKoB5ijaGA?si=ro-49uN6Z1Y__KWh&t=778)  
[Просто про setTimeout, setInterval](https://www.youtube.com/watch?v=5-L__pswmCo)  
[Еще примеры](https://www.youtube.com/watch?v=puxkpNbCh0w)  

* `setTimeout(callbackFn, delay, [, param1[, param2[, paramN]]])` - отложенный на время `delay` в мс однократный запуск `callbackFn` с переданными параметрами
>При переполнении задержки Timeout (превышает 32битное целое число со знаком), Timeout будет вызван немедленно  
`setTimeout(() => console.log("called"), Infinity); // значение задержки будет установлено в 1`
* `setInterval(callbackFn, delay[, param1[, param2[, paramN]]])` - циклический запуск `callbackFn` с переданными параметрами через каждой интервал `delay` в мс

>`delay` в функиях `setInterval`, `setTimeout` - **минимальное** время(не точное), через которое запустится `callbackFn`, т.к. асинхронные функции выполняются после завершения синхронного кода [13. Event Loop](#13-event-loop)  

Функции возвращают идентификатор таймера. Для прерывания таймеров необходимо передать идентификатор в `clearTimeout()`, `clearInterval()`  

**Создание `setInterval` через `setTimeout`:**
`setInterval` запускает выполнение новой итерации через `delay` относительно **начала предыдущей итерации** без учета времени выполнения `callbackFn`.  
Может возникнуть переполнение стека вызовов - падение кода с ошибкой (Maximum call stack size exceeded), если `callbackFn` выполняется дольше `delay`  
Кастомный `setInterval`, созданный через `setTimeout` запускается через `delay` после **окончания выполнения `callbackFn`** в предыдущей итерации.
![График рекурсивного setTimeout и setInterval](https://www.technicalfeeder.com/images/recursive-function-setTimeout-setInterval.png)

```javaScript
const customSetInterval = (cb, delay, ...params) => { 
	setTimeout(() => { 
		cb(...params)
		customSetInterval(cb, delay, ...params) 
	}, delay)  
}
```

**Пример блокировки таймера**  
`setInterval` сработает с задержкой большей, чем в `delay`  
```javascript
setTimeout(() => { console.log(Date.now()) })
console.log(Date.now() + ' start block')
let z = 0;
for(let i = 0; i < 1e6; i++){ 
	z++
} 
console.log(Date.now() + ' end block')
```
[Еще один пример с задержкой в setInterval](https://dev.to/miteshkamat27/delayed-function-execution-in-setinterval-34ib)  

[Вернуться к содержанию](#содержание)

### 11.5 Observer'ы  

Observer - механизм для асинхронного отслеживания изменений и событий. К ним относятся:  
* [Intersection Observer](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API) - наблюдение за пересечением целевого элемента с границами заданного контейнера или viewport (область наблюдения)
* [Mutation Observer](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)  - наблюдение за изменениями структуры в DOM
* [Resize Observer](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver) - наблюдение за изменениямя размеров элементов
* [Performance Observer](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver) - наблюдение за событиями производительности, например LargestContentfulPaint 
* [Reporting Observer](https://developer.mozilla.org/en-US/docs/Web/API/ReportingObserver/ReportingObserver) - наблюдение за событиями отчетов

Разбор на примере **Intersection Observer**  
Конструктор: `new IntersectionObserver(callback, options)`, где  
* `callback(entries, observer)` - функция выполняемая при пересечении области и элементов  
	* `entries` - список объектов IntersectionObserverEntry (для каждого целевого элемента) с информацией о пересечении. 
	* `observer` - ссылка на экземпляр наблюдателя. Содержит методы:  
		* `observe(element)` - запуск наблюдения за целевым элементом
		* `unobserve(element)` - удаление целевого элемента из списка наблюдаемых
		* `disconnect()` - остановка наблюдения за всеми целевыми элементами
		* `takeRecords()` - возвращает массив объектов IntersectionObserverEntry для всех целевых элементов, которые пересекли область с момента последней проверки
* `options` - объект с опциями наблюдателя  
	* `root` - область (по умолчанию viewport) для отслеживания пересечения с целевым элементом
	* `rootMargin` - отступ от root
	* `threshold` - доля пересечения области, при которой срабатывает callback (число или массив)

Свойства объекта IntersectionObserverEntry:
* `isIntersecting` - boolean, есть ли пересечение элемента с наблюдаемой областью
* `intersectionRatio` - доля (от 0 до 1) пересечения целевого элемента с областью. 1 - полностью пересек, 0.5 - наполовину 
* `target` - целевой элемент
* `boundingClientRect` - `getBoundingClientRect()` для целевого элемента
* `intersectionRect` - `getBoundingClientRect()` для область пересечения целевого элемента с областью
* `rootBounds` - `getBoundingClientRect()` области смещенной на rootMargin
* `time` - DOMHighResTimeStamp с момента создания документа до пересечения целевого элемента с областью
Используется для lazy загрузки контента, создания "бесконечного скролла" на сайте  
```javascript
const targetElement = document.querySelector('.element')
const callback = (entries, observer) => {
	entries.forEach({isIntersecting, intersectionRatio, target} => {
		if(isIntersecting) {
			if(intersectionRatio > 0 && intersectionRatio < 1) console.log('Начало пересечения')
			if(intersectionRatio === 1) console.log('Конец пересечения')
			observer.unobserve(entry.target)
		}
	})
}
const options = {
	rootMargin: '0px 0px 75px',
	threshold: [0, 1]
}

const observer = new IntersectionObserver(callback, options)
observer.observe(targetElement)
```
[Производительность Intersection Observer в сравнении с Scroll listener](https://itnext.io/1v1-scroll-listener-vs-intersection-observers-469a26ab9eb6)

[Вернуться к содержанию](#содержание)

### 11.6 queueMicrotask, requestAnimationFrame, requestIdleCallback  

`window.requestAnimationFrame(callback)` - асинхронная функция, запускающая `callback` перед следующей перерисовкой экрана.   
Возвращает уникальный ID для заданного `callback`. Для отмены выполнения: `cancelAnimationFrame(callbackID)`
Колбек-функция принимает аргумент DOMHighResTimeStamp (аналог выполнения `performance.now()`)
Особенности:  
* Синхронизирует выполнение callback с частотой обновления экрана  
* Приостанавливается, если вкладка в фоновом режиме или скрыта в `<iframe>`

`window.requestIdleCallback(callback, options)` - асинхронная функция, запускающая `callback` в периоды простоя браузера
Возвращает уникальный ID для заданного `callback`. Для отмены выполнения: `cancelIdleCallback(callbackID)`
Объект options включает одно свойство timeout - время задержки выполнения callback в мс.  

`queueMicrotask(callback)` - добавляет переданный `callback` в очередь микротасок [13. Event Loop](#13-event-loop)  
Используется для отложенного выполнения `callback`, после синхронного кода 

[Вернуться к содержанию](#содержание)

## 12. Error Handling  

JS имеет встроенные виды ошибок:  
* EvalError - ошибка в функции `eval()`
* RangeError - ошибки диапазона значений  
* ReferenceError - ошибка обращения к несуществующим данным
* SyntaxError - синтаксические ошибки
* TypeError - обращение к несуществующим свойствам  
* URIError - ошибка обработки URI  
* AggregateError - вид ошибки, представляющая объединение нескольких ошибок, обернутых в одну в одну  
```javascript
const errors = [new Error('First error'), new Error('Second error')];
const aggregateError = new AggregateError(errors, 'Multiple errors');
```

**Создание кастомной ошибки:** `const myError = new Error(message)`  
Конструктор возвращает объект ошибки со свойствами message(текст ошибки) и name(имя ошибки)  

Создание собственного класса ошибки, расширяющего базовый: 
```javascript
class customError extends Error {
	constructor(message) { 
		super(message) 
		this.name = 'customErrorName'
	}  
}
const myCustomError = new customError('Error text')
throw myCustomError
```  

Ключевое слово **throw** генерирует исключение, выполнение текущей функции останавливается (код после throw не будет выполнен)

---

`try...catch` - конструкция позволяющая обрабатывать ошибки, не останавливая работу программы  
* `try{}` - блок экранирования уязвимого для ошибок кода  
* `catch(error){}` - блок перехвата и обработки ошибок  
Рекомендуется обрабатывать только те ошибки, которые связаны с данным модулем  
Чтобы пробросить ошибку выше:  
```javascript
const calculate = () => {
	try { ...вычисления } 
	catch (err) {
		// пробрасываем ошибку в блок выше
		if(error.name !== 'innerError') throw err
		console.log('inner error')
	}
}
try { calculate() } 
catch (err) { console.log('outer error') }
```
* `finally{}` - необязательный блок, позволяющий продолжить обработку после успешного выполнения в `try` или перехвата ошибки в `catch`  
Выполняется после try и catch  
```javascript
(() => {
  try {
    return 2;
  } finally {
    return 3;
  }
})(); // 3
```

>`try...catch` работает **только синхронно**  
   
Для обработки асинхронно возникающих ошибок нужно использовать синтаксис async/await  
```javascript
async function myFunc() {  
	try { 
	 // останавливаем выполнение кода, для перехвата ошибки  
	 // при отсутствии await сначала выполнится весь синхроный код - try..catch, затем асинхронный промис
		await Promise.reject('err') 
	} catch (err) { 
		console.log(err)
	}  
}
```

[Вернуться к содержанию](#содержание)

## 13. Event Loop

[Отличный разбор Event Loop](https://www.youtube.com/watch?v=zDlg64fsQow)  
[Для тех кто еще не понял, дополнительные примерамы ч1](https://www.youtube.com/watch?v=3naT39judvQ)  
[Для тех кто еще не понял, дополнительные примерамы ч2](https://www.youtube.com/watch?v=kZFLHCz2a30)  

**JS - однопоточный, синхронный**. Для реализации асинхронности используется WebAPI браузера.
Механизм Event Loop - отвечает за очередность выполнения.  
Связанные понятия:  
* Call Stack - текущее место выполнение кода, куда добавляются команлы по принципу LIFO
* Callback Queue - очередь выполнения асинхронных команд, управляемая Event Loop. Делится на:
	* Macrotask queue - очередь событий
	* Microtask queue - очередь задач  
	
В Call Stack попадает _контекст выполнения команды (Execution Context)_ - структура, сохраняющая служебные данные (область видимости, строку вызова, this и т.д.)
Размер Call Stack ограничен и зависит от среды выполнения скрипта.  
Call Stack блокируется из-за:
1. Переполнения Call Stack
2. alert, promt, confirm
3. Тяжелые вычисления  

**Пример работы Call Stack:**  
```javascript
function one(){}
function two(){ one() } 
function three(){ two() }
three()
```
Порядок попадения в Call Stack (слева направо):  
`...|......|......|one...|......|......|...`  
`...|......|two...|two...|two...|......|...`  
`...|three |three |three |three |three |...`  

[Вернуться к содержанию](#содержание)

### 13.1 Очередность
 
1. все вызовы из Call Stack
2. все вызовы из Microtask queue
3. 1 вызов из Macrotask queue (если Call Stack и Microtask queue пусты, то выполняется следующая Macrotask)  

**Микротаски создают:**
* Promise
* queueMicrotask
* Observer'ы

**Макротаски создают:**
* Таймеры (setTimeout, setInterval)
* События addEventListener (клик, загрузка изображения и т.д.)
* AJAX-запросы

Пример:
```javascript
console.log('Synchronized start');
const myPromise = new Promise((resolve) => {
	console.log('Before promise timeout')
	setTimeout(() => {
		console.log('Before promise resolve')
		resolve('Microtask completed')
		console.log('After promise resolve')
	}, 0)
	console.log('After promise timeout')
})
setTimeout(() => {
  console.log('Macrotask setTimeout');
}, 0);
myPromise
   .then((res) => {
     console.log(res);
   })
Promise.resolve().then(() => console.log('Resolve microtask'))
requestAnimationFrame(() => {
  console.log('First requestAnimationFrame: animation update');
});
requestAnimationFrame(() => {
  console.log('Second requestAnimationFrame: animation update');
});

console.log('Synchronized end');
```
Последовательность вывода:  
1. Synchronized start
2. Before promise timeout
3. After promise timeout
4. Synchronized end
5. Resolve microtask
6. First requestAnimationFrame: animation update
7. Second requestAnimationFrame: animation update
8. Before promise resolve
9. After promise resolve
10. Microtask completed
11. Macrotask setTimeout

На очередность также влияет процесс перерисовки страницы. Он вмешивается в общую очередь по правилам "под капотом" браузера (Render queue).
Браузер пытается вставить requestAnimationFrame в ближайший рендеринг, поэтому `requestAnimationFrame` стремятся происходить примерно раз в 16 мс, но строго после выполнения всех микротасок.  
Поэтому порядок вызовов `requestAnimationFrame` и мАкрозадач может варьироваться.  
Также нужно разбивать тяжелые задачи, чтобы дать браузеру перерендерить страницу (даже если браузер не нуждается в новой отрисовке) - это избавит от дрожания анимации в будущем.  
[Пример порядка выполнения](https://dev.to/bymarsel/unraveling-macrotasks-and-microtasks-in-javascript-what-every-developer-should-know-53mc)

>Прежде чем попасть в micro/macrotask queue команды обрабатываются в webAPI.  
Например, `setTimeout(() => {}, delay)` попадет в очередь после `delay` мс.  
Поэтому, если за время ожидания (`delay`) произойдут более быстрые асинхронные события, например срабатывание `click` (при установнном eventListener), то они попадут в очередь быстрее таймера.  

[Вернуться к содержанию](#содержание)

## 14. Модульность  

Модульность - позволяют разбивать большой проект на отдельные части  
Доступ к данным между модулями осуществляется через `import`, `export`  
**Виды импорта/экспорта:**
- Именованный
```javascript
// index.js
export const data = () => {}
// another module
import { data } from './index.js' 
```
- По умолчанию (единственное объявление в модуле)  
При экспорте по умолчанию при импортировании данных можно указывать любые (в том числе несовпадающме) названия
```javascript
// index.js
export default const data = ''
// another module
import exportData from './index.js' 
```
Именованный и импорт по умолчанию можно объединять: `import defaultImport, { namedImport } from './index.js'`  
[Примеры именованного экспорта и экспорта по умолчанию](https://www.youtube.com/watch?v=TtSemE_0F2k)
- Множественный (импорт всех экспортируемых данных): `import * as data from './index.js'`

При импортировании данных, можно изменить название через ключевое слово `as`: `import { data as exportData } from './index.js' `
Изменения в экспортированных объектах отражаются во всех модулях, импортирующих данные, т.к. объекты - ссылочный тип  
```javaScript
// module1.js
export obj = {name: 'Petr'}
// module2.js
import {obj} from './module1.js'
obj.name = 'Olga'
// module3.js
import {obj} from './module.js'
console.log(obj) // {name: 'Olga'}
```
Решение проблемы - создание фабрики для генерации однотипных объектов: `export function createObj = return {name: 'Petr'}`

[Вернуться к содержанию](#содержание)

## 15. Web-worker  

WebWorker - API для выполнения кода вне основного потока.  
Веб воркер создается в основном потоке. После загрузки скрипта воркера создается отдельный поток и собственный контекст отличный от window (self)  
Создание воркера: 
* `new Worker()` - доступен только в потоке, который его создал  
Общение между потоками осуществляется через асинхронный метод `postMessage`   
* `new SharedWorker()` - доступен в любом потоке 
Общение между потоками осуществляется через асинхронный метод `postMessage` в свойстве `port`  
>Данные отправленные через `postMessage` копируются, что ресурсозатратно при передаче большого объема данных  

```javaScript
// index.js
const worker = new Worker('worker.js')
worker.postMessage({name: 'Petr'})
worker.onmessage = (e) => { console.log(e) }

// завершение работы воркера
myWorker.terminate();

// woker.js
onmessage = (e) => {
	console.log(e.message)
	postMessage({age: 18})
}
```

Список доступных API внутри воркера ограничен. Доступны: `fetch, setInterval, setTimeout, requestAnimationFrame, queueMicrotask`  
[Полный список](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Functions_and_classes_available_to_workers)  

[Видео-пример](https://www.youtube.com/watch?v=Gcp7triXFjg)  
[Больше примеров MDN](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)

[Вернуться к содержанию](#содержание)

## 16. Работа с памятью  

`cookie`, `localStorage`, `sessionStorage` - способы хранения данных в браузере (токенов, идентификаторов сессии, пользовательских настроек и т.д.)  
||cookie|localStorage|sessionStorage|
|----|----|----|----|
|Создание|На сервере(при установке Set-Cookie заголовка) и клиенте|На клиенте|На клиенте|
|Срок жизни|Устанавливается при создании (по умолчанию до закрытия браузера)|Ручное удаление|До закрытия вкладки|
|Объем данных|4 Кб|5Мб|5Мб|
|Доступность в разных браузерных сессиях|зависит от срока жизни|да|нет|
|Доступность во вкладках|Любая вкладка|Любая вкладка|В пределах одной вкладки|
|Доступность клиент/сервер|Клиент/Сервер|Только клиент|Только клиент|

[Вернуться к содержанию](#содержание)

### 16.1 cookie

Добавление/изменение `cookie`:    
```javascript
document.cookie = "first_name=petr";
document.cookie = "age=18";

console.log(document.cookie); // "first_name=petr; age=18"
// изменение значения куки
document.cookie = "age=21";
console.log(document.cookie); // "first_name=petr; age=21"
```  
Дополнительные параметры можно передать через `;`: `document.cookie = 'name=petr;secure;max-age=100'`  
* `path` - роут по которому доступна кука
* `domain` - домен для куки (по умолчанию текущий). `.` перед доменом разрешает доступ ко всем поддоменам: `.my-domain.ru` 
* `max-age` - время жизни куки в секундах
* `expires` - точное время, когда кука станет недействительной  
Для удаления куки устанавливается дата в прошлом `expires=${new Date(0)}`
* `secure` - возможность передачи куки только по HTTPS
* `samesite` - определяет возможность отправки при кроссдоменном запросе (strict - запрещено, lax - разрешено с GET-запросом)

Если название куки начинается с `__Secure-`, то обязательно должны быть установлен параметр `secure`  
Если название куки начинается с `__Host-`, то обязательно должны быть установлены параметры `path` и `secure` и исключен `domains`  
>Сервер может ограничить доступ к куке через JS установив параметр HttpOnly  

[Вернуться к содержанию](#содержание)

### 16.2 Web Storage
  
Методы работы с `localStorage`, `sessionStorage`:  
* `setitem(key, value)` - установка/изменение данных. Данные хранятся в формате String
* `getItem(key)` - получение данных по ключу `key` или null
* `removeItem(key)` - удаление данных
* `clear()` - полная очистка хранилища
* `length` - количество полей в хранилище
* `key(index)` - получение ключа по индексу
```javascript
const person = { name: 'Petr', age: 18 }
window.localStorage.setItem('person', JSON.stringify(person))
```
При установке значения в `localStorage` срабатывает событие `storage`, в котором доступны свойства:  
* `key` - ключ, который был изменен (при вызове метода clear - null)
* `oldValue` - старое значение
* `newValue` - новое значение
* `url` - адрес страницы, на которой произошло изменение

>Браузеры автоматически удаляют данные из хранилища по определенным условиям  
Для постоянного хранения данных нобходимо вызвать `window.navigator.storage?.persist()`  

[Вернуться к содержанию](#содержание)

### 16.3 IndexedDB

Способ хранения большого объема данных в БД браузера. В отличие от Web Storage сохраняет файлы, объекты, примитивные типы.  

* `IDBFactory` - интерфейс доступа к БД
	* `IndexedDB.open(name[, version])` - открытие соединения с БД (создание и открытие, если не существует). Возвращает IDBOpenDBRequest
	* `IndexedDB.deleteDatabase(name)` - удаление БД
	* `IndexedDB.databases()` - возвращает массив объектов содержащих имена-версии всех доступных БД  
* `IDBRequest`
	* `IDBRequest.result` - результат запроса
	* `error` - **событие** срабатывает при ошибке запроса к БД
	* `success` - **событие** срабатывает при успешном запросе к БД
* `IDBOpenDBRequest` - интерфейс предоставляет доступ к результатам запросов на открытие или удаление БД  
Интерфейс не содержит собственных методов, наследуется от IDBRequest
	* `blocked` - **событие** срабатывает, когда открытое соединение с БД блокиреут транзакцию на той же БД
	* `upgradeneeded` - **событие** срабатывает в случае обращения к БД с версией превышающей текущую версию БД
* `IDBDatabase` - интерфейс для управления транзакциями БД
	* `IDBDatabase.close()` - закрывает соединение с БД
	* `IDBDatabase.createObjectStore(name[, options])` - создает и возвращает новое объектное хранилище с именем `name`  
		* `keyPath` - уникальный ключ идентификации элемента в объектном хранилище
		* `autoIncrement` - boolean. Необязательное поле в опциях для автоинкретента ключа (по умолчанию false)  
		Совместное использование опций приведет к ошибке  
	* `IDBDatabase.deleteObjectStore(name)` - удаление объектного хранилища 
	* `IDBDatabase.transaction(storeNames[, mode[, options]])` - создание новой транзакции (IDBTransaction), где  
		* `storeNames` - объектное хранилище или массив объектных хранилищ
		* `mode` - режим транзации (readonly - только чтение, readwrite - чтение и запись)
		* `options` = объект с полем durability (правило устойчивости транзакций).  
		Значения: `strict` - данные должны быть устойчивы к сбою (наибольшая ресурсозатратность), `relaxed` - допускается потеря данных (используется для быстро меняющихся данных), `default` - стандартное поведение браузера
* `IDBTransaction` - интерфейс транзакции 
	* `IDBTransaction.db` - БД, к которой привязана транзакциями
	* `IDBTransaction.durability` - возвращает значение устойчивости транзакции
	* `IDBTransaction.mode` - возвращает значение режима транзакции
	* `IDBTransaction.error` - возвращает DOMException в случае ошибки в транзакции
	* `IDBTransaction.objectStoreNames` - возвращает DOMStringList с именами IDBObjectStore связанных с транзакцией
	* `IDBTransaction.abort()` -метод откатывающий все изменения в БД связанные с транзакцией
	* `IDBTransaction.objectStore(name)` -метод возвращающий IDBObjectStore связанный с транзакцией
* `IDBObjectStore` - интерфейс объектного хранилища в БД
	* `IDBObjectStore.indexNames` - список имен индексов объектного хранилища
	* `IDBObjectStore.keyPath` - keyPath объектного хранилища
	* `IDBObjectStore.name` - name объектного хранилища
	* `IDBObjectStore.transaction` - транзакция связанная с объектным хранилищем
	* `IDBObjectStore.autoIncrement` - autoIncrement объектного хранилища
	* `IDBObjectStore.add(value, key)` - добавляет запись в объектное хранилище
	* `IDBObjectStore.put(item, key)` - обновляет или создает новую запись
	* `IDBObjectStore.delete(key)` - удалят запись в хранилище по ключу или диапазону ключей (IDBKeyRange)
	* `IDBObjectStore.createIndex(indexName, keyPath[, options])` - создает новый индекс. Возвращает IDBIndex 
	* `IDBObjectStore.deleteIndex(indexName)` - удаляет индек
	* `IDBObjectStore.clear([query])` - очищает объектное хранилище от всех записей (query - диапазон IDBKeyRange для удаления)
	* `IDBObjectStore.get(key)` - возвращает запись по заданному ключу или диапазону ключей (IDBKeyRange)
	* `IDBObjectStore.getAll([query[, count]])` - возвращает все (или count) записей по ключу `query` или диапазону ключей (IDBKeyRange) 
	* `IDBObjectStore.count()` - возвращает количество записей в объектном хранилище
	* `IDBObjectStore.index(name)` - открывает индекс для доступа к серии записей по данному индексу
	* `и т.д.`
>Все операции с IndexDB асинхронны и возвращают промис

```javaScript
const indexedDB = 
	window.indexedDB || 
	window.mozIndexedDB || 
	window.webkitIndexedDB || 
	window.msIndexedDB || 
	window.shimIndexedDB;
const request = indexedDB.open('UserDB', 1);

request.onerror = (e) => { console.log('error', e) }
request.onupgradeneeded = () => {
	const db = request.result
	const store = db.createObjectStore('users', {keyPath: 'id'}) // аналог primary_key
	// создание индексов для ускорение поиска, сортировки фильтрации данных в объектном хранилище
	store.createIndex('users_sex', ['sex'], {unique: false})
	store.createIndex('city_and_country', ['city', 'country'], {unique: false})
}
request.onsuccess = () => {
	const db = request.result
	const transaction = db.transaction('users', 'readwrite')
	
	const store = transaction.objectStore('users')
	const sexIndex = store.index('sex')
	const cityAndCountryIndex = store.index('city_and_country')
	
	store.put({id: 1, sex: 'male', city: 'Washington', country: 'USA'})
	store.put({id: 2, sex: 'female', city: 'Manchester', country: 'UK'})
	store.put({id: 3, sex: 'male', city: 'Frankfort', country: 'USA'})
	
	const sexQuery = sexIndex.getAll(['male']);
	sexQuery.onsuccess = () => { console.log(sexQuery.result) }
	
	const cityAndCountryQuery = cityAndCountryIndex.get(['Washington', 'USA'])
	cityAndCountryQuery.onsuccess = () => { console.log(cityAndCountryQuery.result) }
	transaction.oncomplete = () => { db.close() }
}
```

Разобраные только основные методы и интерфейсы  
[Более подробно MDN](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API)  
[Видео-пример работы с IndexedDB](https://www.youtube.com/watch?v=yZ26CXny3iI)

[Вернуться к содержанию](#содержание)

## 17. throttle и debounce

Многие события, такие как scroll, resize срабатывают слишком часто. Для ограничения частоты срабатывания применяют `throttle` и `debounce`  
`throttle(fn)` - ограничивает частоту вызова функции по определенному интервалу времени 
`debounce(fn)` - ограничивает частоту вызова функции до определенного интервала времени с момента последнего вызова  

```javascript
const throttle = (fn, delay) => {
	let timeout = null;
	return function perform(...args) {
		if(!timeout) {
			timeout  = setTimeout(() => {
				fn.apply(this, args)
				clearTimeout(timeout)
				timeout = null
			}, delay)
		}
	}
}
```

```javascript
const debounce = (fn, delay) => {
	let timeout;
	return function (...args) {
		clearTimeout(timeout)
		timeout = setTimeout(() => fn.apply(this, args), delay)
	}
}
```

Вариант типизации любой функции, проходящий strict линтера (без any, unknown)
```typescript
const throttle = <F extends (...args: Parameters<F>) => 
	ReturnType<F>>(fn: F, delay: number): ((...args: Parameters<F>) => void)
```

[Вернуться к содержанию](#содержание)

## 18. Дополнительно

WeakRef - способ создать слабую ссылку на объект.  
`deref()` - метод доступа к объекту со слабой ссылкой. Возвращает объект или undefined  
При отсутствии сильных (обычных) ссылок объект может быть удален сборщиком мусора  

```javascript
const weakRef = new WeakRef({ name: 'Petr' })
const obj = weakObj.deref();
```

`new FinalizationRegistry(callback)` - позволяет запустить `callback` после удаления сборщиком мусора зарегистрированного объекта  
* register(target, heldValue[, unregisterToken]) - регистрация объекта `target`, где 
	* heldValue - данные передаваемые в `callback`
	* unregisterToken - токен для отмены регистрации
* unregister(unregisterToken) - отмена регистрации объекта

```javascript
const myObject = { name: 'Petr' }; // сильная ссылка
const weakRef = new WeakRef(myObject); // слабая ссылка

const registry = new FinalizationRegistry((heldValue) => { console.log(`${heldValue} очищен`) });
registry.register(myObject, "Объект");
myObject = null; // удаляем сильную ссылку на объект

setTimeout(() => {
	const obj = weakRef.deref();
	if (obj) { console.log("Object alive:", obj) } 
	else { console.log("Object deleted") }
}, 10000);
```

[Популярные вопросы для собеседования фронтенда](https://www.greatfrontend.com/questions/quiz)
ШРИ 2022 года
[Продвинутый JS](https://www.youtube.com/watch?v=LVVgJGvq_go)  
[Функциональное програмирование в JS](https://www.youtube.com/watch?v=jAJ79PLkdMA)  
[Типизация, но поверхностно](https://youtu.be/yZ26CXny3iI?si=NRJTxDDhzW14cob2&t=682)

[Вернуться к содержанию](#содержание)








 


