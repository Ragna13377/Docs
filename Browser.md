# Как же все-таки работает браузер

**Общий вид запроса:**  
URL: `http://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#smthInTheDocument`  
`[протокол][домен][порт][путь][строка запроса(query string)][якорь]`  

Виды протоколов:
* http (порт 80)
* https (http + tls) (порт 443) - стандартный протокол веба 
* ssh
* ftp
* mailto
* tel
* и т.д.

_Домен_ - запоминающийся аналог IP-адреса.  
_Порт_ - На сервере могут работать различные приложения (почтовый сервер, веб-сервер и т.д.). Порт определяет к чему мы будем обращаться.  
**Сокет** - комбинация из [домен][порт].   
_Путь_ - путь к ресурсу на сервере.  
_Строка_ запроса - передаваемые параметры серверу.  
_Якорь_ - никогда не передается на сервер. Прокручивает область просмотра до указанного элемента с якорем.  

## 1. DNS Lookup

[About DNS](https://www.youtube.com/watch?v=27r4Bzuj5NQ)

Для преобразования доменного имени в IP браузер последовательно:
Проверка IP-адреса в кэше
1. Кэш браузера
2. Кэш ОС
3. Файл hosts
4. DNS-resolver {DNS провайдера / Облачный DNS (например cloudflare) / DNS Goodle (8.8.8.8 или 8.8.4.4)}  

Если DNS-resolver не содержит ответа запускается последовательное обращение к DNS серверам:  
* Root-сервер (Хранит адреса всех TLD DNS-серверов)
* TLD-сервер (Отвечает за зону: com, ru, net и т.д.)
* Authoritative-сервер (Отвечает за дочернюю зону `ru.`**`wikipedia`**`.com`)  
После получения IP адреса, адрес заносится в кэш (локально,  в DNS-resolver) и устанавливаем TCP соединение с сервером.

![DNS Lookup](https://habrastorage.org/r/w1560/getpro/habr/upload_files/f42/297/7ac/f422977aca7d88ffd757c33a48382979.jpeg)  

DNS сервера работают в 2 режимах:
* Итеративный - сервер возвращает IP, если он отвечает за запрашиваемую доменную зону, иначе адрес DNS-сервера, который может знать об этом домене.
* Рекурсивный - сервер выполняет запросы к другим DNS-серверам, пока не узнает нужный IP-адрес.

Пример:
Корневой DNS - итеративный. Большую нагрузка из-за большого количества обращений, вычисление IP оказывается ресурсозатратным. 
DNS resolver - рекурсивный. 

## 2. TCP соединение

[TCP Handshake ](https://www.youtube.com/watch?v=xMtP5ZB3wSk)  

**TCP Handshake** - установка соединения (Seq# - случайное число, SYN, ACK - флаги)  

* `Client --- SYN: 1 Seq#: 5002 --> Server` - Клиент отправляет SYN-пакет, запрашивая синхронизацию (соединение)  
* `Client <-- SYN: 1 ACK: 5003 Seq#: 3455 --- Server - Сервер подтверждает запрос на синхронизацию со своей стороны и запрашивает синхронизацию у клиента  
* `Client --- ACK: 3456 Seq#: 5003 --> Server` - Клиент подтверждает запрос на синхронизацию   

## 3. TLS

[SSL, TLS, HTTPS Explained (на примере TLS 1.2)](https://www.youtube.com/watch?v=j9QmMEWmcfo)  
[Полный разбор TLS 1.2 на примере шифрования RSA](https://www.youtube.com/watch?v=ZkL10eoG1PY)  
[Установка соединения TLS на русском](https://www.youtube.com/watch?v=lKfyM980cOw)  
[Шифрование Диффи-Хелмана (наиболее популярное и безопасное)](https://www.youtube.com/watch?v=kCkQRH5eweg)  
[Детальный разбор сообщений TLS](https://tls.dxdt.ru/tls.html#logic)  

**TLS Handshake** - TLS имеет гирбридное шифрование. 
Публичный ключ для симметричного шифрования передается ассиметричным шифрованием.  
Последующая передача данных осуществляется c симметричным шифрованием.  

**Виды шифрований:**  
* Ассиметричное - Открытый ключ может распространяться без ограничений. Скорость медленая
* Симметричное шифрование - Ключ должен храниться в тайне. Скорость быстрая   

**Certificate Check** - установка шифрования  
* `Client --- Client Hello --> Server` - Поддерживаемая версия TLS, список поддерживаемых шифронаборов, случайное число клиента 32б (cliet random), которое будет использоваться для симметричного шифрования 
* `Client <-- Server Hello --- Server` - Версия протокола, которую будут использовать клиент и сервер и выбранный шифронабор, случайное число сервера (server random), идентификатор сессии (для восстановления соединения)
* `Client <-- Certificate --- Server` - Сертификат с Public Key (открытый ключ сервера), подписанный удостоверяющим центром  
* `Client <-- Server Key Exchange --- Server` - **Необязательное сообщение**. Зависит от типа шифрования. Отсутствует в TLS 1.3. Передает данные для вычисления сеансового ключа.  
* `Client <-- Server Hello Done --- Server` - Пустое сообщение сообщаееще, что сервер закончил передачу данных   

На клиенте происходит проверка сертификата: подписей удостоверяющих центров, проверка доверия удостоверяющему центру (совпадает ли с разрешенными на стороне клиента)  
проверка домена сертификата (на случай подмены), проверка срока действия сертификата, проверка не отозван ли сертификат и т.д.

**Key Exchange**  - клиент создает сессионный ключ, шифрует его с помощью публичного ключа сервера, который может быть расшифрован только с помощью приватного ключа, хранящегося на сервере.  
* `Client --- Client Key Exchange --> Server` - Данные генерируемые из Certificate и/или Server Key Exchange используемые для вычисления сеансового ключа (Pre-maser secret). Зависят от типа шифрования.   
* `Client --- Change Cipher Spec --> Server` - Клиент подтверждает, что сменил тип шифрования и следующие TLS сообщения будут зашифрованы  
* `Client --- Finished --> Server` - Первое зашифрованное сообщение клиента для подтверждения сервером, что параметры согласованы правильно  
* `Client <-- Change Cipher Spec --- Server` - Сервер подтверждает, что сменил тип шифрования и следующие TLS сообщения будут зашифрованы  
* `Client <-- Finished --- Server` - Первое зашифрованное сообщение сервера для подтверждения сервером, что параметры согласованы правильно  

На основе Pre-master secret, clien random и server random генерируются с обеих сторон ключи для симметричного шифрования и ключи MAC

В Client Hello и Server Hello передается идентификатор сессии на случай восстановления соединения.
Тогда процесс соединения сокращается до:
* Client --- Client Hello --> Server  
* Client <-- Server Hello --- Server  
* Client <-- Change Cipher Spec --- Server  
* Client <-- Finished --- Server  
* Client --- Change Cipher Spec --> Server  
* Client --- Finished --> Server  

Для прекращения соединения отправляется сообщение `close_notify`. Сервер обязан передать ответное сообщение `close_noify`.  
В отличие от TCP после отправки сообщения клиент игнорирует все идущие со стороны сервера сообщения.  

**Сообщения отправляемые подряд могут быть объединены** в одно сообщение.

## 3.1 Различие TLS 1.2 и TLS 1.3

[Полный разбор TLS 1.3](https://www.youtube.com/watch?v=JA0vaIb4158)  
[Детальный разбор сообщений TLS](https://tls.dxdt.ru/tls.html#logic)
[Отличие TLS 1.2 от TLS 1.3 более простым языком](https://web.archive.org/web/20231203050511/https://tproger.ru/articles/tls-handshake-explained)

Уменьшение количество сообщений до начала передачи данных до 0-1 RTT (Один круг между Клиент-Сервером)  
При TLS 1.2:   
* 1 круг -  DNS соединение  
* 2 круг - (SYN, SYN+ACK)  
* 3 круг - (ACK + Client Hello, Server Hello, ..., Server Hello Done)  
* 4 круг - (Смена шифрования клиентом и сервером)  
* 5 круг - (передача данных)  

Сокращение число поддерживаемых шифров с 37 до 5  
Для каждой сессии генерируется отдельный ключ шифрования
Внедрена проверка сертификата клиента на стороне сервера - сервер в ответном сообщении может запросить сертификат клиента для проверки

* `Client --- Client Hello, Client key_share --> Server` - Вместе с Client Hello клиент пытается угадать алгоритм(так как число шифров сокращено) и передать данные для вычисления ключа шифрования.  
* `Client <-- Server Hello, Server key_share, Certificate, Finished --- Server`   
* `Client --- Finished --> Server`

На основе *Client key_share и Server key_share* (Видоизмененные сообщения Client/Server Key Exchange) - генерируется ключ симметричного шифрования.  
**Если клиент не угадал** тип шифрования, то сервер отправляет сообщение `HelloRetryRequest` и высылает свой `Server key_share`. Далее повторяет схему TLS 1.3.  

В случае, когда клиент хочет возобновить сессию, он может передать в первом сообщении early_data. Тогда **RTT составит 3 круга**, а TLS займет **0 кругов**, так как данные поступят при первом ответе сервера в TLS соединении.

## 4. Передача данных по http

[HTTP/1 to HTTP/2 to HTTP/3](https://www.youtube.com/watch?v=a-sBfyiXysI)  
[HTTP/1.1](https://www.youtube.com/watch?v=F-TMrtM8NBs)  
[HTTP/2](https://www.youtube.com/watch?v=SZHpnohrbIQ)  
[демо HTTP/1.1 vs HTTP/2 ](https://web.archive.org/web/20230208202803/https://http2.akamai.com/demo)  
[отличная статья нововведений HTTP/2](https://habr.com/ru/companies/nix/articles/304518/)  
[QUIC Transport Protocol](https://www.youtube.com/watch?v=HnDsMehSSY4)  
[Авито: подробно про HTTP/3 ](https://www.youtube.com/watch?v=T_4xgLUJFF0)  
[1-3 части про HTTP/3 и QUIC ](https://habr.com/ru/companies/slurm/articles/575464/)  

**История:**
HTTP/1 - для каждого запроса к серверу требуется открытие нового TCP-соединения  
Сообщения передаются в текстовом формате, но структура сообщения стандиртизирована  
* HTTP/1.1:  
	* введен режим keep-alive для повторного использования существующего TCP-соединения.  
	* добавлена конвейерная обработка HTTP (pipeline). Можно отправлять новые запросы, не дожидаясь предыдущих, но ответы должны приходить в точной последовательноси запросам.   
В связи с этим возникла проблема `Head-of-line Blocking` на уровне запросов, когда новый ответ ждет передачи предыдущего.  
* HTTP/2  
Данные делятся на части (frame) и передаются в пределах одного соединения, но в разных потоках (stream).  
Последовательность frame имеющих один идентификатор - stream (поток)  
Структура сообщения не изменилась.  
Для переключения версии нужно отправить заголовок (Upgrade: HTTP/2.0). Сервер ответит информационным сообщеннием о переключении  
	* мультиплексирование запросов  
Для отправки новых запросов не нужно создавать новые TCP-соединения, для отправки нового запроса нужно создать новый поток.     
Не нужно ожидать отправки предыдущего запроса при работе в одном соединении (решена проблема `Head-of-line Blocking`)  
Данные внутри запрос/ответа разделяются на *frame* (HEADERS / DATA / PRIORITY / PING и т.д.)  
Последовательность важна только в рамках одного stream (DATA не должно быть раньше HEADERS запроса)  
Последовательность в отправке разных потоков не фиксирована  
	* запросы/ответы передаются в бинарном формате в сжатом виде  
	* HPACK сжатие заголовков
	* приоритезация stream (специальный frame)
	* добавлен механизм закрытия stream (отправкой соответствующего frame)  
В предыдущей версии, так как данные не дробились на фреймы и потоки, прекратить передачу можно только разрывом соединения.  
	* Server Push - сервер без запроса клиента может инициировать отправку обновленных данных  
Функция должна быть включена на стороне клиента.  
_Пример:_ при запросе клиентом html, сервер делает push стилей и картинок  
**Следующие проблемы связаны с TCP передачей:**
1. `Head-of-line Blocking` на уровне TCP. При потере пакета следующие за ним пакеты блокируются в ожидании повторной передачи потерянного пакета  
2. `Bufferbloat` - при выделении буфера для передачи данных, если данные заняли весь буфер, тогда добавление более приоритетного запроса не приведет к его мгновенной отправке, так как место в буфере занято и приоритетный запрос встанет в самый конец очереди.  
* HTTP/3:  
	* транспортный протокол UDP (исключаем первый круг RTT с TCP-Handshake) При первом соединении 3RTT, повторное с early_data 2RTT (1 - DNS, 2 - TLS + HTTP)  
**Fix от ЯП:** UDP управляет контрольными сигналами, TCP все равно используется для передачи
	* механизм QUIC:
  * новый метод сжатия QPACK (создает таблицы сжатия на основе всех потоков)  
	* Loss Recovery - до начала ретрансмита (повторной передачи потерянных пакетов) заранее делаются запросы дошли ли последние пакеты в каждом запросе  
	* IP Migration - отправка не привязана к IP, при смене сети(IP) сможем принять отправленный пакет  
**QUIC решает проблемы `Head-of-line Blocking`** - не блокирует передачу в случае потери пакета.  
На принимающей стороне файл, в котором отсутствует пакет будет ожидать переотправки утерянных пакетов, а цельные данные уже могут быть обработаны.  

Пример HTTP/1 запроса:
```
GET /index.html HTTP/1.1 // requset line (обязательная часть) - состоит из [метода][URL][Version]  
User-Ageng: Mozilla/5.0 // header (заголовки могут отличаться - они необязательны)  
Host: www.example.com // header (единственный обязательный заголовок)  
Accept-Language: ru, en-Us // header  
Accept-Encoding: gzip, deflate // header  
ConnectionL keep-alive // header  

name=user&email=mail@example.com // Request body отделяется от заголовков пустой строкой (необязательная часть)
```

Методы HTTP:  
- GET - получение данных  
- POST - отправка данных / создание новой записи  
- PUT - создание при отсутствии, изменение при наличии (содержит полную версию ресурса)  
- PATCH - изменение при наличии (содержит только измененную часть)  
- DELETE - удаление  
- HEAD, TRACE и т.д.

В ответе приходит Status Line: [Version][Code][Message] - `HTTP/1.1 200 OK`

[Коды ответов](https://www.youtube.com/watch?v=qmpUfWN7hh4)  
* 1хх - информационное сообщение
* 2хх - успешное выполнение
* 3хх - перенаправление
* 4хх - ошибка на стороне клиента
* 5хх - ошибка на стороне сервера

[HTTP headers](https://www.youtube.com/watch?v=1v7RoeXyww4)
* General  
* Request  
* Response  
* Entity - применяются для контента (например длина)  

## 5. Детальный разбор на примере Chrome  

_Процессы запускаемые при работе браузера:_
1. Browser Process включает в себя UI-thread (UI-интерфейс), network-thread (сетевые запросы), storage-thread (доступ к файлам)
2. Plugin Process - управляет плагинами
3. GPU Process - обрабатывает задачи GPU
4. Renderer Process - рендер страницы.   
5. и т.д.  

Для каждой вкладки или iframe запускается свой рендер процесс, каждый из которых имеет копию общей инфраструктуры движка.  
При превышении максимально допустимого количества независимых процессов, новые вкладки начинают запускаться в одном процессе  
_Аналогичный подход при создании Browser Process_  

* **Обработка ввода**  
Когда пользователь вводит URL в адресную строку, UI-thread анализирует нужно ли перенаправить запрос в поисковую систему или сразу перейти на сайт  
* **Начало навигации** 
Когда пользователь нажимает `Enter`, UI thread инициирует создание network-thread (происходит DNS Lookup, TCP/TLS Handshake)  
Появляется индикатор загрузки в углу вкладки.  
При возникновении редиректа network-thread сообщает об этом UI-thread и происходит новый запрос URL-адреса  
* **Чтение ответа (payload)** 
network-thread проверяет корректность MIME-тип в заголовке `Content-Type`, выполняет SafeBrowsing и CORB  
	* если ответ является HTML файлом, то данные передаются в Renderer Process 
	* если ответ является zip или другим типом файла, то данный запрос представляет загрузку и передается в менеджер загрузок  
	
_SafeBrowsing - проверка вредоносных сайтов_  
_CORB - проверка, что межсайтовые данные не попадают в Renderer Process_  
* **Поиск Renderer Process**   
После завершения проверок, когда network-thread уверен, что браузер может перейти по URL, он сообщает UI-thread, что данные готовы  
UI-thread ищет Renderer Process для начала рендеринга веб-страницы, т.к. сетевой запрос можен занять несколько мс,   
в целях оптимизации UI-thread параллельно началу навигации запускает Renderer Process,  
тогда Renderer Process будет находиться в режиме ожиданя к моменту получения данных. 
* **Реализация перехода**  
Когда данные и Renderer Process готовы, Browser Process запрашивает Renderer Process для реализации перехода и передает  
поток данных, чтобы Renderer Process мог продолжать получать HTML данные.  
Когда Browser Process получит подтверждение из Renderer Process, что все выполнено, навигация завершается.  
На данном этапе обновляется адресная строка, индикатор безопасности сайта и на новой вкадке в UI отражается информация о сайте (title)  
Обновляется история сеанса для вкладки (для перехода по истории вперед/назад)  
История сеанса сохраяется на диск для облегчения восстановления вкладки  
* **Дополнительный шаг: завершение первоначальной загрузки**   
После завершения навигации Renderer Process продолжает загрузку ресурсов и рендер страницы (далее в 5.1)  
При "завершении" рендера страницы (когда сработает `onload` на всех фреймах страницы) Renderer Process уведомляет об этом Browser Process  
Останавливается анимация индикатора загрузки, **НО** клиентский JS может продолжать загружать дополнительные ресурсы и изменить отрендеренную часть  

---

**Переход на другой сайт**  
Если пользователь вводит новый URL, начинается новая навигация (те же шаги) на другой сайт, создается отдельный Renderer Process для ее обработки.  
Старый Renderer Process сохраняется для обработки события `beforeunload`  
При переходе на новый сайт через интерфейс сайта, процесс навигации запускается из Renderer Process в Browser Process  

**Использование Servise Worker**  
**SW** - JS код, запускаемый в Renderer Process. При регистрации SW сохраняется его scope в качестве ссылки.  
При навигации newtwork-thread проверяет наличие доменного имени в scope SW  
Если SW настроен на загрузку страницы из кэша, то пропадает необходимость загрузки данных из сети  

При общении между Browser Process и Renderer Process могут произойти задержки, если SW решит, что нужно запросить данные из сети  
**Navigation Preload** позволяет ускорить этот процесс, загружая ресурсы параллельно запуску SW.  
Данный запрос помечается отдельным header, что позволяет серверу отправлять разное содержимое, вместо полного документа

## 5.1 Обработка web-контента

### Парсинг

**Создание DOM**  
* Преобразование байтов в символы
* Токенизация - разбитие входных значений на токены (открывающие, закрывающие теги, названия и значения атрибутов)
* Лексирование - токены преобразуются в объекты, которые определяют их свойства и правила
* Построение DOM - создание дерева из токенов  

DOM - описывает содержимое документа в друвовидно структуре 
HTML преобразуется в DOM по стандартм HTML.  
При преобразовании учитываются и исправляются ошибки (незакрытый тег, неправильный порядок тегов и т.д.)  
* Загрузка внешних ресурсов (стили, изображения и т.д.) из сети или кэша.  
Main-thread запрашивает ресурсы в порядке расположения в HTML при парсинге для создания DOM.  
Для ускорения загрузки запускается `preload scanner`, анализирующий теги `<link>, <img>` и отправляющий запросы network-thread в Browser Process  
Скрипты могут блокировать парсинг, до выполнения кода скрипта, т.к. JS может изменить форму документа (значит и сам DOM)  
**НО** браузер прододжает синтаксический анализ html после запуска скрипта и при наличии дальше ссылок на внешние ресурсы начнет загружать эти данные  
Атрибуты `async` и `defer` позволяют загружать скрипты асинхронно (подробнее в Hints.md)

**Создание CSSOM** - Main-thread разбирает стили (аналогично DOM), строит CSSOM и определяет computed стиль для каждого узла DOM  
CSS является блокирующим обработку ресурсом, т.к. из-за каскадной природы стили могут перезаписывать друг друга,   
поэтому Render Tree не может быть построено без полного разбора CSS   

**Создание Render Tree (DOM + CSSOM)**  
Для построения Render Tree браузер проходит по каждому видимому узлу DOM (невидимые: метатеги, комментарии, скрытые стилями и т.д.),  
применяет к ним подходящие правила из CSSOM, генерирует видимые узлы с computed стилями  

**Создание Abstract Syntax Tree** - разбор скриптов в AST и их компиляция  

**Создание AOM** -  дерево доступности для вспомогательных технологий (скринридеров и т.д.)  
### Рендер
**Layout** - создание Layout Tree (дерево видимых элементов, содержащих координаты и размеры ограничивающих прямоугольников)  
Для упрощения перекомпоновки используется систему "грязного бита" (dirty bit).  
Доступно 2 флага: dirty (узлу нужна компоновка) , children as dirty (в узле есть дочерний элемент, которому нужна компоновка)  

Алгоритм генерации макета с учетом системы "dirty bit":  
1. Родительский узел определяет собственную ширину
2. Родительский узел проходит по дочерним узлам и рассчитывает размеры дочерних узлов или вызывает рассчет макета у дочерних узлов, имеющих грязных потомков  
3. Родительский узел обновляет собственную высоту
4. Устанавливает "грязный бит" false  

**Paint** - отрисовка  
Main-thread проходит по Layout Tree для создания Paint Records (запись хода отрисовки блочного рендера)  

>Каждый последующий этап использует результат предыдущего, поэтому изменение деревьев может быть ресурсозатратным  
_Для отображения анимации без задержки потребуется обновить экран 60раз/сек_  
Любые блокирующие скрипты следует оптимизировать, например дробить на чанки и запускать в `requestAnimationFrame` или использовать WebWorker

**Compositing** - разделение частей страницы на слои, растеризация(непосредственно отрисовка пикселей) их по отдельности и  
композиция слоев в отдельном compositor-thread  
* **Деление на слои** - Main-thread проходит по Layout Tree и создает Layer Tree  
_Большое количество слоев приводит к более медленной работе, чем растеризация маленьких частей страницы в каждом кадре_  
* **Растеризация и композиция вне главного потока**  
Main-thread отправляет Layer Tree и Paint Records в compositor-thread, где каждый слой растеризуется.  
Т.к. слой может быть большим (вплоть до всей страницы), то они делятся на tiles и отправляет каждый tile в raster-thread  
Raster-threads растеризуют каждый tail и сохраняют его в памяти GPU  
При этом compositor-thread может расставлять приоритеты для разных raster-thread, чтобы объекты во viewport были растеризованы первыми  
После растеризации compositor-thread собирает информацию о tiles в draw quads и создает compositor frame  
**Отрисовка квадратнов (draw quads)** - информацию о месте в памяти и месте на странице для отрисовки с учетом композиции  
**Compositor frame** - коллекция draw quads, представляющая кадр страницы  
Compositor frame передается в Browser Process.  
В этот же момент могут быть получены другие compositor frame из UI-thread или других Renderer Process  
Все Compositor frame отправляются в GPU для вывода на экране

[Самая важный цикл статей](https://habr.com/ru/articles/526696/)  
[Как работает браузер - оригинал полный](https://web.dev/articles/howbrowserswork)  
[Как работает браузер - оригинал сокращенный](https://dev.to/gitpaulo/journey-of-a-web-page-how-browsers-work-10co)  
[Как работает браузер - перевод](https://habr.com/ru/companies/skillfactory/articles/678400/)  
[Дополнительный неплохой перевод статей](https://web.dev/articles/critical-rendering-path?hl=ru)  
[Картинки преобразований](https://habr.com/ru/companies/dataart/articles/304138/)  

## Дополнительно

[CORS](https://www.youtube.com/watch?v=uSo3_ILwlQs)  
[What happens when you type a URL into your browser?](https://www.youtube.com/watch?v=AlkDbnbv7dk)  
[Поверхностный разбор](https://www.youtube.com/watch?v=c8VW5_PtxU0)


[Чикуенок](https://www.youtube.com/watch?v=On2EWADF81Y)  

Layout срабатывает после обращения к свойствам связанным с геометрией, если они были изменены.

В примере Layout будет вызываться столько же раз, сколько элементов в массиве, потому что обращаемся к геометрии элемента на каждой итерации:  
```javascript
const elements = document.querySelector('p')
const rects = [];
for(const elem of elements) {
	elem.style.width = 50% // изменение геометрии  
	rects.push(elem.getBoundingClientRect()); // обращение к свойству связанному с геометрией  
}
```
В примере Layout будет вызван 1 раз, так как обращение произошло после всех изменений
```javascript
const elements = document.querySelector('p')
const rects = [];` 
for(const elem of elements) { 
	elem.style.width = 50%
}
for(const elem of elements) {
	rects.push(elem.getBoundingClientRect());
}
```
